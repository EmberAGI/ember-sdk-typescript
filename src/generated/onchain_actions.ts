// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: onchain_actions.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal.js";
import { Timestamp } from "./google/protobuf/timestamp.js";

export enum CapabilityType {
  CAPABILITY_TYPE_UNSPECIFIED = 0,
  SWAP = 1,
  LENDING = 2,
  UNRECOGNIZED = -1,
}

export function capabilityTypeFromJSON(object: any): CapabilityType {
  switch (object) {
    case 0:
    case "CAPABILITY_TYPE_UNSPECIFIED":
      return CapabilityType.CAPABILITY_TYPE_UNSPECIFIED;
    case 1:
    case "SWAP":
      return CapabilityType.SWAP;
    case 2:
    case "LENDING":
      return CapabilityType.LENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CapabilityType.UNRECOGNIZED;
  }
}

export function capabilityTypeToJSON(object: CapabilityType): string {
  switch (object) {
    case CapabilityType.CAPABILITY_TYPE_UNSPECIFIED:
      return "CAPABILITY_TYPE_UNSPECIFIED";
    case CapabilityType.SWAP:
      return "SWAP";
    case CapabilityType.LENDING:
      return "LENDING";
    case CapabilityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Chain type enum */
export enum ChainType {
  UNSPECIFIED = 0,
  EVM = 1,
  SOLANA = 2,
  COSMOS = 3,
  UNRECOGNIZED = -1,
}

export function chainTypeFromJSON(object: any): ChainType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return ChainType.UNSPECIFIED;
    case 1:
    case "EVM":
      return ChainType.EVM;
    case 2:
    case "SOLANA":
      return ChainType.SOLANA;
    case 3:
    case "COSMOS":
      return ChainType.COSMOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChainType.UNRECOGNIZED;
  }
}

export function chainTypeToJSON(object: ChainType): string {
  switch (object) {
    case ChainType.UNSPECIFIED:
      return "UNSPECIFIED";
    case ChainType.EVM:
      return "EVM";
    case ChainType.SOLANA:
      return "SOLANA";
    case ChainType.COSMOS:
      return "COSMOS";
    case ChainType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Order type for token swaps */
export enum OrderType {
  ORDER_TYPE_UNSPECIFIED = 0,
  MARKET_BUY = 1,
  MARKET_SELL = 2,
  LIMIT_BUY = 3,
  LIMIT_SELL = 4,
  UNRECOGNIZED = -1,
}

export function orderTypeFromJSON(object: any): OrderType {
  switch (object) {
    case 0:
    case "ORDER_TYPE_UNSPECIFIED":
      return OrderType.ORDER_TYPE_UNSPECIFIED;
    case 1:
    case "MARKET_BUY":
      return OrderType.MARKET_BUY;
    case 2:
    case "MARKET_SELL":
      return OrderType.MARKET_SELL;
    case 3:
    case "LIMIT_BUY":
      return OrderType.LIMIT_BUY;
    case 4:
    case "LIMIT_SELL":
      return OrderType.LIMIT_SELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderType.UNRECOGNIZED;
  }
}

export function orderTypeToJSON(object: OrderType): string {
  switch (object) {
    case OrderType.ORDER_TYPE_UNSPECIFIED:
      return "ORDER_TYPE_UNSPECIFIED";
    case OrderType.MARKET_BUY:
      return "MARKET_BUY";
    case OrderType.MARKET_SELL:
      return "MARKET_SELL";
    case OrderType.LIMIT_BUY:
      return "LIMIT_BUY";
    case OrderType.LIMIT_SELL:
      return "LIMIT_SELL";
    case OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Status of the transaction plan creation */
export enum TransactionPlanStatus {
  TRANSACTION_PLAN_STATUS_UNSPECIFIED = 0,
  /** SUCCESS - Valid transaction data was created */
  SUCCESS = 1,
  /** ERROR - Failed to create valid transaction data */
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function transactionPlanStatusFromJSON(object: any): TransactionPlanStatus {
  switch (object) {
    case 0:
    case "TRANSACTION_PLAN_STATUS_UNSPECIFIED":
      return TransactionPlanStatus.TRANSACTION_PLAN_STATUS_UNSPECIFIED;
    case 1:
    case "SUCCESS":
      return TransactionPlanStatus.SUCCESS;
    case 2:
    case "ERROR":
      return TransactionPlanStatus.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionPlanStatus.UNRECOGNIZED;
  }
}

export function transactionPlanStatusToJSON(object: TransactionPlanStatus): string {
  switch (object) {
    case TransactionPlanStatus.TRANSACTION_PLAN_STATUS_UNSPECIFIED:
      return "TRANSACTION_PLAN_STATUS_UNSPECIFIED";
    case TransactionPlanStatus.SUCCESS:
      return "SUCCESS";
    case TransactionPlanStatus.ERROR:
      return "ERROR";
    case TransactionPlanStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Transaction type for different chains */
export enum TransactionType {
  TRANSACTION_TYPE_UNSPECIFIED = 0,
  EVM_TX = 1,
  SOLANA_TX = 2,
  COSMOS_TX = 3,
  UNRECOGNIZED = -1,
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case "TRANSACTION_TYPE_UNSPECIFIED":
      return TransactionType.TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "EVM_TX":
      return TransactionType.EVM_TX;
    case 2:
    case "SOLANA_TX":
      return TransactionType.SOLANA_TX;
    case 3:
    case "COSMOS_TX":
      return TransactionType.COSMOS_TX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.TRANSACTION_TYPE_UNSPECIFIED:
      return "TRANSACTION_TYPE_UNSPECIFIED";
    case TransactionType.EVM_TX:
      return "EVM_TX";
    case TransactionType.SOLANA_TX:
      return "SOLANA_TX";
    case TransactionType.COSMOS_TX:
      return "COSMOS_TX";
    case TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** New messages for provider tracking status */
export enum ProviderStatus {
  PROVIDER_STATUS_UNSPECIFIED = 0,
  PROVIDER_STATUS_SUCCESS = 1,
  PROVIDER_STATUS_PARTIAL_SUCCESS = 2,
  PROVIDER_STATUS_NEEDS_GAS = 3,
  PROVIDER_STATUS_NOT_FOUND = 4,
  PROVIDER_STATUS_ONGOING = 5,
  UNRECOGNIZED = -1,
}

export function providerStatusFromJSON(object: any): ProviderStatus {
  switch (object) {
    case 0:
    case "PROVIDER_STATUS_UNSPECIFIED":
      return ProviderStatus.PROVIDER_STATUS_UNSPECIFIED;
    case 1:
    case "PROVIDER_STATUS_SUCCESS":
      return ProviderStatus.PROVIDER_STATUS_SUCCESS;
    case 2:
    case "PROVIDER_STATUS_PARTIAL_SUCCESS":
      return ProviderStatus.PROVIDER_STATUS_PARTIAL_SUCCESS;
    case 3:
    case "PROVIDER_STATUS_NEEDS_GAS":
      return ProviderStatus.PROVIDER_STATUS_NEEDS_GAS;
    case 4:
    case "PROVIDER_STATUS_NOT_FOUND":
      return ProviderStatus.PROVIDER_STATUS_NOT_FOUND;
    case 5:
    case "PROVIDER_STATUS_ONGOING":
      return ProviderStatus.PROVIDER_STATUS_ONGOING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProviderStatus.UNRECOGNIZED;
  }
}

export function providerStatusToJSON(object: ProviderStatus): string {
  switch (object) {
    case ProviderStatus.PROVIDER_STATUS_UNSPECIFIED:
      return "PROVIDER_STATUS_UNSPECIFIED";
    case ProviderStatus.PROVIDER_STATUS_SUCCESS:
      return "PROVIDER_STATUS_SUCCESS";
    case ProviderStatus.PROVIDER_STATUS_PARTIAL_SUCCESS:
      return "PROVIDER_STATUS_PARTIAL_SUCCESS";
    case ProviderStatus.PROVIDER_STATUS_NEEDS_GAS:
      return "PROVIDER_STATUS_NEEDS_GAS";
    case ProviderStatus.PROVIDER_STATUS_NOT_FOUND:
      return "PROVIDER_STATUS_NOT_FOUND";
    case ProviderStatus.PROVIDER_STATUS_ONGOING:
      return "PROVIDER_STATUS_ONGOING";
    case ProviderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SwapCapability {
  capabilityId: string;
  supportedTokens: Token[];
}

export interface LendingCapability {
  capabilityId: string;
  currentSupplyApy: string;
  currentBorrowApy: string;
  underlyingToken?:
    | Token
    | undefined;
  /** Maximum Loan-to-Value ratio for this lending/supply capability */
  maxLtv: string;
  /** Liquidation threshold for the borrowed asset */
  liquidationThreshold: string;
}

/** The Capability wrapper uses a oneof to capture exactly one of the distinct types. */
export interface Capability {
  swapCapability?: SwapCapability | undefined;
  lendingCapability?: LendingCapability | undefined;
}

/** Request to get capabilities, filtered by the type and paginated. */
export interface GetCapabilitiesRequest {
  type: CapabilityType;
}

/** Response containing the list of capabilities, with pagination token. */
export interface GetCapabilitiesResponse {
  capabilities: Capability[];
}

export interface Chain {
  chainId: string;
  type: ChainType;
  iconUri: string;
  nativeToken?: Token | undefined;
  httpRpcUrl: string;
  name: string;
  blockExplorerUrls: string[];
  /** Timestamps */
  updatedAt?: Date | undefined;
}

export interface Token {
  /** For native tokens, this may be empty. */
  tokenUid?: TokenIdentifier | undefined;
  name: string;
  symbol: string;
  isNative: boolean;
  decimals: number;
  iconUri?:
    | string
    | undefined;
  /**
   * Store as a string to avoid floating-point precision issues.
   * e.g., "123.456789"
   */
  usdPrice?: string | undefined;
  isVetted: boolean;
  /** Timestamps */
  updatedAt?: Date | undefined;
}

/** Request to get chains, with optional filtering/pagination. */
export interface GetChainsRequest {
  filter: string;
}

export interface GetChainsResponse {
  chains: Chain[];
}

/** Request to get tokens, with optional filter by chain_id, plus pagination. */
export interface GetTokensRequest {
  /** If empty, returns tokens across all chains. */
  chainId: string;
  filter: string;
}

export interface GetTokensResponse {
  tokens: Token[];
}

/** Identifies a token on a specific chain */
export interface TokenIdentifier {
  /** TODO: use number */
  chainId: string;
  address: string;
}

/** Request to swap tokens */
export interface SwapTokensRequest {
  orderType: OrderType;
  baseToken?: TokenIdentifier | undefined;
  quoteToken?: TokenIdentifier | undefined;
  amount: string;
  limitPrice?: string | undefined;
  slippageTolerance?:
    | string
    | undefined;
  /** Changed from deadline */
  expiration?: string | undefined;
  recipient: string;
}

/** Error details when transaction plan creation fails */
export interface TransactionPlanError {
  /** e.g., "INSUFFICIENT_LIQUIDITY" */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Additional context about the error */
  details: { [key: string]: string };
}

export interface TransactionPlanError_DetailsEntry {
  key: string;
  value: string;
}

/** Response containing the swap details */
export interface SwapTokensResponse {
  /** Changed from SwapStatus */
  status: TransactionPlanStatus;
  orderType: OrderType;
  /** Echo back the token details */
  baseToken?: TokenIdentifier | undefined;
  quoteToken?:
    | TokenIdentifier
    | undefined;
  /** Fee and transaction details */
  feeBreakdown?: FeeBreakdown | undefined;
  transactionPlan?: TransactionPlan | undefined;
  estimation?:
    | SwapEstimation
    | undefined;
  /** Tracking information from the provider */
  providerTracking?:
    | ProviderTrackingInfo
    | undefined;
  /** Error details if status is ERROR */
  error?: TransactionPlanError | undefined;
}

/** Fee breakdown for the swap */
export interface FeeBreakdown {
  serviceFee: string;
  slippageCost: string;
  total: string;
  feeDenomination: string;
}

/** Chain-specific transaction plan */
export interface TransactionPlan {
  type: TransactionType;
  to: string;
  data: string;
  value: string;
}

/** Estimation details for the swap */
export interface SwapEstimation {
  baseTokenDelta: string;
  quoteTokenDelta: string;
  effectivePrice: string;
  timeEstimate: string;
  expiration: string;
}

/** Tracking information from the provider */
export interface ProviderTrackingInfo {
  requestId: string;
  providerName: string;
  explorerUrl: string;
}

export interface GetProviderTrackingStatusRequest {
  requestId: string;
  transactionId: string;
}

export interface ProviderTrackingStatus {
  requestId: string;
  transactionId: string;
  providerName: string;
  explorerUrl: string;
  status: ProviderStatus;
}

export interface GetProviderTrackingStatusResponse {
  trackingStatus?: ProviderTrackingStatus | undefined;
}

/** Request to borrow tokens. */
export interface BorrowTokensRequest {
  tokenUid?: TokenIdentifier | undefined;
  amount: string;
  borrowerWalletAddress: string;
}

/** Response containing the borrow transaction details. */
export interface BorrowTokensResponse {
  currentBorrowApy: string;
  liquidationThreshold: string;
  feeBreakdown?: FeeBreakdown | undefined;
  transactions: TransactionPlan[];
  error?: TransactionPlanError | undefined;
}

/** Request for wallet positions, with pagination support. */
export interface GetWalletPositionsRequest {
  walletAddress: string;
}

/** Response containing the list of wallet positions. */
export interface GetWalletPositionsResponse {
  positions: WalletPosition[];
}

/** A wrapper message that uses oneof to represent a wallet position of a specific type. */
export interface WalletPosition {
  /**
   * Future extensions: VaultPosition vault_position = 2;
   *                   TokenBalance token_balance = 3;
   */
  lendingPosition?: LendingPosition | undefined;
}

/** Represents details of a borrow position. This mirrors the schema defined in borrowAdapter.ts. */
export interface BorrowPosition {
  /** Wallet address of the borrower. */
  borrowerWalletAddress: string;
  /** Total liquidity available in USD. */
  totalLiquidityUsd: string;
  /** Total collateral value in USD. */
  totalCollateralUsd: string;
  /** Total amount borrowed in USD. */
  totalBorrowsUsd: string;
  /** Net worth calculated as collateral minus borrows in USD. */
  netWorthUsd: string;
  /** Health factor of the borrow position. */
  healthFactor: string;
  /** Detailed positions for each token in the borrow position. */
  positions: TokenPosition[];
}

/** Represents a token position within a wallet's borrow position. */
export interface TokenPosition {
  /** The underlying asset for this token position. */
  underlyingToken?:
    | Token
    | undefined;
  /** Borrow rate for this token, if applicable. */
  borrowRate: string;
  /** Supply balance for this token (if supplied as collateral). */
  supplyBalance: string;
  /** Borrow balance for this token. */
  borrowBalance: string;
  /** Combined USD value of this position. */
  valueUsd: string;
}

/** New message definitions for lending positions */
export interface LendingPosition {
  userReserves: LendTokenDetail[];
  totalLiquidityUsd: string;
  totalCollateralUsd: string;
  totalBorrowsUsd: string;
  netWorthUsd: string;
  availableBorrowsUsd: string;
  currentLoanToValue: string;
  currentLiquidationThreshold: string;
  healthFactor: string;
}

export interface LendTokenDetail {
  token?: Token | undefined;
  underlyingBalance: string;
  underlyingBalanceUsd: string;
  variableBorrows: string;
  variableBorrowsUsd: string;
  totalBorrows: string;
  totalBorrowsUsd: string;
}

export interface RepayTokensRequest {
  tokenUid?: TokenIdentifier | undefined;
  amount: string;
  borrowerWalletAddress: string;
}

export interface RepayTokensResponse {
  tokenUid?: TokenIdentifier | undefined;
  amount: string;
  borrowerWalletAddress: string;
  feeBreakdown?: FeeBreakdown | undefined;
  transactions: TransactionPlan[];
  error?: TransactionPlanError | undefined;
}

export interface SupplyTokensRequest {
  tokenUid?: TokenIdentifier | undefined;
  amount: string;
  supplierWalletAddress: string;
}

export interface SupplyTokensResponse {
  tokenUid?: TokenIdentifier | undefined;
  amount: string;
  supplierWalletAddress: string;
  feeBreakdown?: FeeBreakdown | undefined;
  transactions: TransactionPlan[];
  error?: TransactionPlanError | undefined;
}

/** New message definitions for withdraw operations: */
export interface WithdrawTokensRequest {
  tokenUid?: TokenIdentifier | undefined;
  amount: string;
  lenderWalletAddress: string;
}

export interface WithdrawTokensResponse {
  tokenUid?: TokenIdentifier | undefined;
  amount: string;
  lenderWalletAddress: string;
  feeBreakdown?: FeeBreakdown | undefined;
  transactions: TransactionPlan[];
  error?: TransactionPlanError | undefined;
}

export interface GetLendingUserSummaryRequest {
  userAddress: string;
}

export interface LendingReserve {
  tokenUid?: TokenIdentifier | undefined;
  symbol: string;
  decimals: number;
  supplyRate: string;
  borrowRate: string;
  reserveFactor: string;
  reserveLiquidationThreshold: string;
}

export interface GetLendingReservesResponse {
  reserves: LendingReserve[];
}

function createBaseSwapCapability(): SwapCapability {
  return { capabilityId: "", supportedTokens: [] };
}

export const SwapCapability = {
  encode(message: SwapCapability, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.capabilityId !== "") {
      writer.uint32(10).string(message.capabilityId);
    }
    for (const v of message.supportedTokens) {
      Token.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapCapability {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.capabilityId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.supportedTokens.push(Token.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapCapability {
    return {
      capabilityId: isSet(object.capabilityId) ? globalThis.String(object.capabilityId) : "",
      supportedTokens: globalThis.Array.isArray(object?.supportedTokens)
        ? object.supportedTokens.map((e: any) => Token.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SwapCapability): unknown {
    const obj: any = {};
    if (message.capabilityId !== "") {
      obj.capabilityId = message.capabilityId;
    }
    if (message.supportedTokens?.length) {
      obj.supportedTokens = message.supportedTokens.map((e) => Token.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapCapability>, I>>(base?: I): SwapCapability {
    return SwapCapability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapCapability>, I>>(object: I): SwapCapability {
    const message = createBaseSwapCapability();
    message.capabilityId = object.capabilityId ?? "";
    message.supportedTokens = object.supportedTokens?.map((e) => Token.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLendingCapability(): LendingCapability {
  return {
    capabilityId: "",
    currentSupplyApy: "",
    currentBorrowApy: "",
    underlyingToken: undefined,
    maxLtv: "",
    liquidationThreshold: "",
  };
}

export const LendingCapability = {
  encode(message: LendingCapability, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.capabilityId !== "") {
      writer.uint32(10).string(message.capabilityId);
    }
    if (message.currentSupplyApy !== "") {
      writer.uint32(18).string(message.currentSupplyApy);
    }
    if (message.currentBorrowApy !== "") {
      writer.uint32(26).string(message.currentBorrowApy);
    }
    if (message.underlyingToken !== undefined) {
      Token.encode(message.underlyingToken, writer.uint32(34).fork()).ldelim();
    }
    if (message.maxLtv !== "") {
      writer.uint32(42).string(message.maxLtv);
    }
    if (message.liquidationThreshold !== "") {
      writer.uint32(50).string(message.liquidationThreshold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendingCapability {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendingCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.capabilityId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currentSupplyApy = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currentBorrowApy = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.underlyingToken = Token.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maxLtv = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.liquidationThreshold = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendingCapability {
    return {
      capabilityId: isSet(object.capabilityId) ? globalThis.String(object.capabilityId) : "",
      currentSupplyApy: isSet(object.currentSupplyApy) ? globalThis.String(object.currentSupplyApy) : "",
      currentBorrowApy: isSet(object.currentBorrowApy) ? globalThis.String(object.currentBorrowApy) : "",
      underlyingToken: isSet(object.underlyingToken) ? Token.fromJSON(object.underlyingToken) : undefined,
      maxLtv: isSet(object.maxLtv) ? globalThis.String(object.maxLtv) : "",
      liquidationThreshold: isSet(object.liquidationThreshold) ? globalThis.String(object.liquidationThreshold) : "",
    };
  },

  toJSON(message: LendingCapability): unknown {
    const obj: any = {};
    if (message.capabilityId !== "") {
      obj.capabilityId = message.capabilityId;
    }
    if (message.currentSupplyApy !== "") {
      obj.currentSupplyApy = message.currentSupplyApy;
    }
    if (message.currentBorrowApy !== "") {
      obj.currentBorrowApy = message.currentBorrowApy;
    }
    if (message.underlyingToken !== undefined) {
      obj.underlyingToken = Token.toJSON(message.underlyingToken);
    }
    if (message.maxLtv !== "") {
      obj.maxLtv = message.maxLtv;
    }
    if (message.liquidationThreshold !== "") {
      obj.liquidationThreshold = message.liquidationThreshold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LendingCapability>, I>>(base?: I): LendingCapability {
    return LendingCapability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LendingCapability>, I>>(object: I): LendingCapability {
    const message = createBaseLendingCapability();
    message.capabilityId = object.capabilityId ?? "";
    message.currentSupplyApy = object.currentSupplyApy ?? "";
    message.currentBorrowApy = object.currentBorrowApy ?? "";
    message.underlyingToken = (object.underlyingToken !== undefined && object.underlyingToken !== null)
      ? Token.fromPartial(object.underlyingToken)
      : undefined;
    message.maxLtv = object.maxLtv ?? "";
    message.liquidationThreshold = object.liquidationThreshold ?? "";
    return message;
  },
};

function createBaseCapability(): Capability {
  return { swapCapability: undefined, lendingCapability: undefined };
}

export const Capability = {
  encode(message: Capability, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.swapCapability !== undefined) {
      SwapCapability.encode(message.swapCapability, writer.uint32(10).fork()).ldelim();
    }
    if (message.lendingCapability !== undefined) {
      LendingCapability.encode(message.lendingCapability, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Capability {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.swapCapability = SwapCapability.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lendingCapability = LendingCapability.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Capability {
    return {
      swapCapability: isSet(object.swapCapability) ? SwapCapability.fromJSON(object.swapCapability) : undefined,
      lendingCapability: isSet(object.lendingCapability)
        ? LendingCapability.fromJSON(object.lendingCapability)
        : undefined,
    };
  },

  toJSON(message: Capability): unknown {
    const obj: any = {};
    if (message.swapCapability !== undefined) {
      obj.swapCapability = SwapCapability.toJSON(message.swapCapability);
    }
    if (message.lendingCapability !== undefined) {
      obj.lendingCapability = LendingCapability.toJSON(message.lendingCapability);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Capability>, I>>(base?: I): Capability {
    return Capability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Capability>, I>>(object: I): Capability {
    const message = createBaseCapability();
    message.swapCapability = (object.swapCapability !== undefined && object.swapCapability !== null)
      ? SwapCapability.fromPartial(object.swapCapability)
      : undefined;
    message.lendingCapability = (object.lendingCapability !== undefined && object.lendingCapability !== null)
      ? LendingCapability.fromPartial(object.lendingCapability)
      : undefined;
    return message;
  },
};

function createBaseGetCapabilitiesRequest(): GetCapabilitiesRequest {
  return { type: 0 };
}

export const GetCapabilitiesRequest = {
  encode(message: GetCapabilitiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetCapabilitiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCapabilitiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCapabilitiesRequest {
    return { type: isSet(object.type) ? capabilityTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: GetCapabilitiesRequest): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = capabilityTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCapabilitiesRequest>, I>>(base?: I): GetCapabilitiesRequest {
    return GetCapabilitiesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCapabilitiesRequest>, I>>(object: I): GetCapabilitiesRequest {
    const message = createBaseGetCapabilitiesRequest();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseGetCapabilitiesResponse(): GetCapabilitiesResponse {
  return { capabilities: [] };
}

export const GetCapabilitiesResponse = {
  encode(message: GetCapabilitiesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.capabilities) {
      Capability.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetCapabilitiesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCapabilitiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.capabilities.push(Capability.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCapabilitiesResponse {
    return {
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => Capability.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetCapabilitiesResponse): unknown {
    const obj: any = {};
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities.map((e) => Capability.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCapabilitiesResponse>, I>>(base?: I): GetCapabilitiesResponse {
    return GetCapabilitiesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCapabilitiesResponse>, I>>(object: I): GetCapabilitiesResponse {
    const message = createBaseGetCapabilitiesResponse();
    message.capabilities = object.capabilities?.map((e) => Capability.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChain(): Chain {
  return {
    chainId: "",
    type: 0,
    iconUri: "",
    nativeToken: undefined,
    httpRpcUrl: "",
    name: "",
    blockExplorerUrls: [],
    updatedAt: undefined,
  };
}

export const Chain = {
  encode(message: Chain, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.iconUri !== "") {
      writer.uint32(26).string(message.iconUri);
    }
    if (message.nativeToken !== undefined) {
      Token.encode(message.nativeToken, writer.uint32(34).fork()).ldelim();
    }
    if (message.httpRpcUrl !== "") {
      writer.uint32(42).string(message.httpRpcUrl);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    for (const v of message.blockExplorerUrls) {
      writer.uint32(58).string(v!);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Chain {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.iconUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nativeToken = Token.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.httpRpcUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.blockExplorerUrls.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chain {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      type: isSet(object.type) ? chainTypeFromJSON(object.type) : 0,
      iconUri: isSet(object.iconUri) ? globalThis.String(object.iconUri) : "",
      nativeToken: isSet(object.nativeToken) ? Token.fromJSON(object.nativeToken) : undefined,
      httpRpcUrl: isSet(object.httpRpcUrl) ? globalThis.String(object.httpRpcUrl) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      blockExplorerUrls: globalThis.Array.isArray(object?.blockExplorerUrls)
        ? object.blockExplorerUrls.map((e: any) => globalThis.String(e))
        : [],
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Chain): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.type !== 0) {
      obj.type = chainTypeToJSON(message.type);
    }
    if (message.iconUri !== "") {
      obj.iconUri = message.iconUri;
    }
    if (message.nativeToken !== undefined) {
      obj.nativeToken = Token.toJSON(message.nativeToken);
    }
    if (message.httpRpcUrl !== "") {
      obj.httpRpcUrl = message.httpRpcUrl;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.blockExplorerUrls?.length) {
      obj.blockExplorerUrls = message.blockExplorerUrls;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chain>, I>>(base?: I): Chain {
    return Chain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chain>, I>>(object: I): Chain {
    const message = createBaseChain();
    message.chainId = object.chainId ?? "";
    message.type = object.type ?? 0;
    message.iconUri = object.iconUri ?? "";
    message.nativeToken = (object.nativeToken !== undefined && object.nativeToken !== null)
      ? Token.fromPartial(object.nativeToken)
      : undefined;
    message.httpRpcUrl = object.httpRpcUrl ?? "";
    message.name = object.name ?? "";
    message.blockExplorerUrls = object.blockExplorerUrls?.map((e) => e) || [];
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseToken(): Token {
  return {
    tokenUid: undefined,
    name: "",
    symbol: "",
    isNative: false,
    decimals: 0,
    iconUri: undefined,
    usdPrice: undefined,
    isVetted: false,
    updatedAt: undefined,
  };
}

export const Token = {
  encode(message: Token, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(10).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.isNative !== false) {
      writer.uint32(32).bool(message.isNative);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).int32(message.decimals);
    }
    if (message.iconUri !== undefined) {
      writer.uint32(50).string(message.iconUri);
    }
    if (message.usdPrice !== undefined) {
      writer.uint32(58).string(message.usdPrice);
    }
    if (message.isVetted !== false) {
      writer.uint32(64).bool(message.isVetted);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Token {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isNative = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.decimals = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.iconUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.usdPrice = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isVetted = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Token {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : false,
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      iconUri: isSet(object.iconUri) ? globalThis.String(object.iconUri) : undefined,
      usdPrice: isSet(object.usdPrice) ? globalThis.String(object.usdPrice) : undefined,
      isVetted: isSet(object.isVetted) ? globalThis.Boolean(object.isVetted) : false,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Token): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.isNative !== false) {
      obj.isNative = message.isNative;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.iconUri !== undefined) {
      obj.iconUri = message.iconUri;
    }
    if (message.usdPrice !== undefined) {
      obj.usdPrice = message.usdPrice;
    }
    if (message.isVetted !== false) {
      obj.isVetted = message.isVetted;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Token>, I>>(base?: I): Token {
    return Token.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Token>, I>>(object: I): Token {
    const message = createBaseToken();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.isNative = object.isNative ?? false;
    message.decimals = object.decimals ?? 0;
    message.iconUri = object.iconUri ?? undefined;
    message.usdPrice = object.usdPrice ?? undefined;
    message.isVetted = object.isVetted ?? false;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetChainsRequest(): GetChainsRequest {
  return { filter: "" };
}

export const GetChainsRequest = {
  encode(message: GetChainsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChainsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainsRequest {
    return { filter: isSet(object.filter) ? globalThis.String(object.filter) : "" };
  },

  toJSON(message: GetChainsRequest): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainsRequest>, I>>(base?: I): GetChainsRequest {
    return GetChainsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainsRequest>, I>>(object: I): GetChainsRequest {
    const message = createBaseGetChainsRequest();
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseGetChainsResponse(): GetChainsResponse {
  return { chains: [] };
}

export const GetChainsResponse = {
  encode(message: GetChainsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.chains) {
      Chain.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChainsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chains.push(Chain.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainsResponse {
    return { chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => Chain.fromJSON(e)) : [] };
  },

  toJSON(message: GetChainsResponse): unknown {
    const obj: any = {};
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => Chain.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainsResponse>, I>>(base?: I): GetChainsResponse {
    return GetChainsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainsResponse>, I>>(object: I): GetChainsResponse {
    const message = createBaseGetChainsResponse();
    message.chains = object.chains?.map((e) => Chain.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTokensRequest(): GetTokensRequest {
  return { chainId: "", filter: "" };
}

export const GetTokensRequest = {
  encode(message: GetTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: GetTokensRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensRequest>, I>>(base?: I): GetTokensRequest {
    return GetTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensRequest>, I>>(object: I): GetTokensRequest {
    const message = createBaseGetTokensRequest();
    message.chainId = object.chainId ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseGetTokensResponse(): GetTokensResponse {
  return { tokens: [] };
}

export const GetTokensResponse = {
  encode(message: GetTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tokens) {
      Token.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokens.push(Token.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensResponse {
    return { tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e: any) => Token.fromJSON(e)) : [] };
  },

  toJSON(message: GetTokensResponse): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => Token.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensResponse>, I>>(base?: I): GetTokensResponse {
    return GetTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensResponse>, I>>(object: I): GetTokensResponse {
    const message = createBaseGetTokensResponse();
    message.tokens = object.tokens?.map((e) => Token.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenIdentifier(): TokenIdentifier {
  return { chainId: "", address: "" };
}

export const TokenIdentifier = {
  encode(message: TokenIdentifier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenIdentifier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenIdentifier {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: TokenIdentifier): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenIdentifier>, I>>(base?: I): TokenIdentifier {
    return TokenIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenIdentifier>, I>>(object: I): TokenIdentifier {
    const message = createBaseTokenIdentifier();
    message.chainId = object.chainId ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseSwapTokensRequest(): SwapTokensRequest {
  return {
    orderType: 0,
    baseToken: undefined,
    quoteToken: undefined,
    amount: "",
    limitPrice: undefined,
    slippageTolerance: undefined,
    expiration: undefined,
    recipient: "",
  };
}

export const SwapTokensRequest = {
  encode(message: SwapTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderType !== 0) {
      writer.uint32(8).int32(message.orderType);
    }
    if (message.baseToken !== undefined) {
      TokenIdentifier.encode(message.baseToken, writer.uint32(18).fork()).ldelim();
    }
    if (message.quoteToken !== undefined) {
      TokenIdentifier.encode(message.quoteToken, writer.uint32(26).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.limitPrice !== undefined) {
      writer.uint32(42).string(message.limitPrice);
    }
    if (message.slippageTolerance !== undefined) {
      writer.uint32(50).string(message.slippageTolerance);
    }
    if (message.expiration !== undefined) {
      writer.uint32(58).string(message.expiration);
    }
    if (message.recipient !== "") {
      writer.uint32(66).string(message.recipient);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baseToken = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.quoteToken = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.limitPrice = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.slippageTolerance = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.expiration = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.recipient = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapTokensRequest {
    return {
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      baseToken: isSet(object.baseToken) ? TokenIdentifier.fromJSON(object.baseToken) : undefined,
      quoteToken: isSet(object.quoteToken) ? TokenIdentifier.fromJSON(object.quoteToken) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      limitPrice: isSet(object.limitPrice) ? globalThis.String(object.limitPrice) : undefined,
      slippageTolerance: isSet(object.slippageTolerance) ? globalThis.String(object.slippageTolerance) : undefined,
      expiration: isSet(object.expiration) ? globalThis.String(object.expiration) : undefined,
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : "",
    };
  },

  toJSON(message: SwapTokensRequest): unknown {
    const obj: any = {};
    if (message.orderType !== 0) {
      obj.orderType = orderTypeToJSON(message.orderType);
    }
    if (message.baseToken !== undefined) {
      obj.baseToken = TokenIdentifier.toJSON(message.baseToken);
    }
    if (message.quoteToken !== undefined) {
      obj.quoteToken = TokenIdentifier.toJSON(message.quoteToken);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.limitPrice !== undefined) {
      obj.limitPrice = message.limitPrice;
    }
    if (message.slippageTolerance !== undefined) {
      obj.slippageTolerance = message.slippageTolerance;
    }
    if (message.expiration !== undefined) {
      obj.expiration = message.expiration;
    }
    if (message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapTokensRequest>, I>>(base?: I): SwapTokensRequest {
    return SwapTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapTokensRequest>, I>>(object: I): SwapTokensRequest {
    const message = createBaseSwapTokensRequest();
    message.orderType = object.orderType ?? 0;
    message.baseToken = (object.baseToken !== undefined && object.baseToken !== null)
      ? TokenIdentifier.fromPartial(object.baseToken)
      : undefined;
    message.quoteToken = (object.quoteToken !== undefined && object.quoteToken !== null)
      ? TokenIdentifier.fromPartial(object.quoteToken)
      : undefined;
    message.amount = object.amount ?? "";
    message.limitPrice = object.limitPrice ?? undefined;
    message.slippageTolerance = object.slippageTolerance ?? undefined;
    message.expiration = object.expiration ?? undefined;
    message.recipient = object.recipient ?? "";
    return message;
  },
};

function createBaseTransactionPlanError(): TransactionPlanError {
  return { code: "", message: "", details: {} };
}

export const TransactionPlanError = {
  encode(message: TransactionPlanError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      TransactionPlanError_DetailsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionPlanError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionPlanError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TransactionPlanError_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.details[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionPlanError {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TransactionPlanError): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionPlanError>, I>>(base?: I): TransactionPlanError {
    return TransactionPlanError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionPlanError>, I>>(object: I): TransactionPlanError {
    const message = createBaseTransactionPlanError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTransactionPlanError_DetailsEntry(): TransactionPlanError_DetailsEntry {
  return { key: "", value: "" };
}

export const TransactionPlanError_DetailsEntry = {
  encode(message: TransactionPlanError_DetailsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionPlanError_DetailsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionPlanError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionPlanError_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionPlanError_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionPlanError_DetailsEntry>, I>>(
    base?: I,
  ): TransactionPlanError_DetailsEntry {
    return TransactionPlanError_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionPlanError_DetailsEntry>, I>>(
    object: I,
  ): TransactionPlanError_DetailsEntry {
    const message = createBaseTransactionPlanError_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSwapTokensResponse(): SwapTokensResponse {
  return {
    status: 0,
    orderType: 0,
    baseToken: undefined,
    quoteToken: undefined,
    feeBreakdown: undefined,
    transactionPlan: undefined,
    estimation: undefined,
    providerTracking: undefined,
    error: undefined,
  };
}

export const SwapTokensResponse = {
  encode(message: SwapTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    if (message.baseToken !== undefined) {
      TokenIdentifier.encode(message.baseToken, writer.uint32(26).fork()).ldelim();
    }
    if (message.quoteToken !== undefined) {
      TokenIdentifier.encode(message.quoteToken, writer.uint32(34).fork()).ldelim();
    }
    if (message.feeBreakdown !== undefined) {
      FeeBreakdown.encode(message.feeBreakdown, writer.uint32(42).fork()).ldelim();
    }
    if (message.transactionPlan !== undefined) {
      TransactionPlan.encode(message.transactionPlan, writer.uint32(50).fork()).ldelim();
    }
    if (message.estimation !== undefined) {
      SwapEstimation.encode(message.estimation, writer.uint32(58).fork()).ldelim();
    }
    if (message.providerTracking !== undefined) {
      ProviderTrackingInfo.encode(message.providerTracking, writer.uint32(66).fork()).ldelim();
    }
    if (message.error !== undefined) {
      TransactionPlanError.encode(message.error, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseToken = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.quoteToken = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeBreakdown = FeeBreakdown.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionPlan = TransactionPlan.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.estimation = SwapEstimation.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.providerTracking = ProviderTrackingInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.error = TransactionPlanError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapTokensResponse {
    return {
      status: isSet(object.status) ? transactionPlanStatusFromJSON(object.status) : 0,
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      baseToken: isSet(object.baseToken) ? TokenIdentifier.fromJSON(object.baseToken) : undefined,
      quoteToken: isSet(object.quoteToken) ? TokenIdentifier.fromJSON(object.quoteToken) : undefined,
      feeBreakdown: isSet(object.feeBreakdown) ? FeeBreakdown.fromJSON(object.feeBreakdown) : undefined,
      transactionPlan: isSet(object.transactionPlan) ? TransactionPlan.fromJSON(object.transactionPlan) : undefined,
      estimation: isSet(object.estimation) ? SwapEstimation.fromJSON(object.estimation) : undefined,
      providerTracking: isSet(object.providerTracking)
        ? ProviderTrackingInfo.fromJSON(object.providerTracking)
        : undefined,
      error: isSet(object.error) ? TransactionPlanError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: SwapTokensResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = transactionPlanStatusToJSON(message.status);
    }
    if (message.orderType !== 0) {
      obj.orderType = orderTypeToJSON(message.orderType);
    }
    if (message.baseToken !== undefined) {
      obj.baseToken = TokenIdentifier.toJSON(message.baseToken);
    }
    if (message.quoteToken !== undefined) {
      obj.quoteToken = TokenIdentifier.toJSON(message.quoteToken);
    }
    if (message.feeBreakdown !== undefined) {
      obj.feeBreakdown = FeeBreakdown.toJSON(message.feeBreakdown);
    }
    if (message.transactionPlan !== undefined) {
      obj.transactionPlan = TransactionPlan.toJSON(message.transactionPlan);
    }
    if (message.estimation !== undefined) {
      obj.estimation = SwapEstimation.toJSON(message.estimation);
    }
    if (message.providerTracking !== undefined) {
      obj.providerTracking = ProviderTrackingInfo.toJSON(message.providerTracking);
    }
    if (message.error !== undefined) {
      obj.error = TransactionPlanError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapTokensResponse>, I>>(base?: I): SwapTokensResponse {
    return SwapTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapTokensResponse>, I>>(object: I): SwapTokensResponse {
    const message = createBaseSwapTokensResponse();
    message.status = object.status ?? 0;
    message.orderType = object.orderType ?? 0;
    message.baseToken = (object.baseToken !== undefined && object.baseToken !== null)
      ? TokenIdentifier.fromPartial(object.baseToken)
      : undefined;
    message.quoteToken = (object.quoteToken !== undefined && object.quoteToken !== null)
      ? TokenIdentifier.fromPartial(object.quoteToken)
      : undefined;
    message.feeBreakdown = (object.feeBreakdown !== undefined && object.feeBreakdown !== null)
      ? FeeBreakdown.fromPartial(object.feeBreakdown)
      : undefined;
    message.transactionPlan = (object.transactionPlan !== undefined && object.transactionPlan !== null)
      ? TransactionPlan.fromPartial(object.transactionPlan)
      : undefined;
    message.estimation = (object.estimation !== undefined && object.estimation !== null)
      ? SwapEstimation.fromPartial(object.estimation)
      : undefined;
    message.providerTracking = (object.providerTracking !== undefined && object.providerTracking !== null)
      ? ProviderTrackingInfo.fromPartial(object.providerTracking)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? TransactionPlanError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseFeeBreakdown(): FeeBreakdown {
  return { serviceFee: "", slippageCost: "", total: "", feeDenomination: "" };
}

export const FeeBreakdown = {
  encode(message: FeeBreakdown, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceFee !== "") {
      writer.uint32(10).string(message.serviceFee);
    }
    if (message.slippageCost !== "") {
      writer.uint32(18).string(message.slippageCost);
    }
    if (message.total !== "") {
      writer.uint32(26).string(message.total);
    }
    if (message.feeDenomination !== "") {
      writer.uint32(34).string(message.feeDenomination);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeeBreakdown {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeBreakdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceFee = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.slippageCost = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.total = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeDenomination = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeeBreakdown {
    return {
      serviceFee: isSet(object.serviceFee) ? globalThis.String(object.serviceFee) : "",
      slippageCost: isSet(object.slippageCost) ? globalThis.String(object.slippageCost) : "",
      total: isSet(object.total) ? globalThis.String(object.total) : "",
      feeDenomination: isSet(object.feeDenomination) ? globalThis.String(object.feeDenomination) : "",
    };
  },

  toJSON(message: FeeBreakdown): unknown {
    const obj: any = {};
    if (message.serviceFee !== "") {
      obj.serviceFee = message.serviceFee;
    }
    if (message.slippageCost !== "") {
      obj.slippageCost = message.slippageCost;
    }
    if (message.total !== "") {
      obj.total = message.total;
    }
    if (message.feeDenomination !== "") {
      obj.feeDenomination = message.feeDenomination;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeBreakdown>, I>>(base?: I): FeeBreakdown {
    return FeeBreakdown.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeBreakdown>, I>>(object: I): FeeBreakdown {
    const message = createBaseFeeBreakdown();
    message.serviceFee = object.serviceFee ?? "";
    message.slippageCost = object.slippageCost ?? "";
    message.total = object.total ?? "";
    message.feeDenomination = object.feeDenomination ?? "";
    return message;
  },
};

function createBaseTransactionPlan(): TransactionPlan {
  return { type: 0, to: "", data: "", value: "" };
}

export const TransactionPlan = {
  encode(message: TransactionPlan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionPlan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionPlan {
    return {
      type: isSet(object.type) ? transactionTypeFromJSON(object.type) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionPlan): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = transactionTypeToJSON(message.type);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionPlan>, I>>(base?: I): TransactionPlan {
    return TransactionPlan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionPlan>, I>>(object: I): TransactionPlan {
    const message = createBaseTransactionPlan();
    message.type = object.type ?? 0;
    message.to = object.to ?? "";
    message.data = object.data ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSwapEstimation(): SwapEstimation {
  return { baseTokenDelta: "", quoteTokenDelta: "", effectivePrice: "", timeEstimate: "", expiration: "" };
}

export const SwapEstimation = {
  encode(message: SwapEstimation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseTokenDelta !== "") {
      writer.uint32(10).string(message.baseTokenDelta);
    }
    if (message.quoteTokenDelta !== "") {
      writer.uint32(18).string(message.quoteTokenDelta);
    }
    if (message.effectivePrice !== "") {
      writer.uint32(26).string(message.effectivePrice);
    }
    if (message.timeEstimate !== "") {
      writer.uint32(34).string(message.timeEstimate);
    }
    if (message.expiration !== "") {
      writer.uint32(42).string(message.expiration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapEstimation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapEstimation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseTokenDelta = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quoteTokenDelta = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.effectivePrice = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeEstimate = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expiration = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapEstimation {
    return {
      baseTokenDelta: isSet(object.baseTokenDelta) ? globalThis.String(object.baseTokenDelta) : "",
      quoteTokenDelta: isSet(object.quoteTokenDelta) ? globalThis.String(object.quoteTokenDelta) : "",
      effectivePrice: isSet(object.effectivePrice) ? globalThis.String(object.effectivePrice) : "",
      timeEstimate: isSet(object.timeEstimate) ? globalThis.String(object.timeEstimate) : "",
      expiration: isSet(object.expiration) ? globalThis.String(object.expiration) : "",
    };
  },

  toJSON(message: SwapEstimation): unknown {
    const obj: any = {};
    if (message.baseTokenDelta !== "") {
      obj.baseTokenDelta = message.baseTokenDelta;
    }
    if (message.quoteTokenDelta !== "") {
      obj.quoteTokenDelta = message.quoteTokenDelta;
    }
    if (message.effectivePrice !== "") {
      obj.effectivePrice = message.effectivePrice;
    }
    if (message.timeEstimate !== "") {
      obj.timeEstimate = message.timeEstimate;
    }
    if (message.expiration !== "") {
      obj.expiration = message.expiration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapEstimation>, I>>(base?: I): SwapEstimation {
    return SwapEstimation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapEstimation>, I>>(object: I): SwapEstimation {
    const message = createBaseSwapEstimation();
    message.baseTokenDelta = object.baseTokenDelta ?? "";
    message.quoteTokenDelta = object.quoteTokenDelta ?? "";
    message.effectivePrice = object.effectivePrice ?? "";
    message.timeEstimate = object.timeEstimate ?? "";
    message.expiration = object.expiration ?? "";
    return message;
  },
};

function createBaseProviderTrackingInfo(): ProviderTrackingInfo {
  return { requestId: "", providerName: "", explorerUrl: "" };
}

export const ProviderTrackingInfo = {
  encode(message: ProviderTrackingInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.providerName !== "") {
      writer.uint32(18).string(message.providerName);
    }
    if (message.explorerUrl !== "") {
      writer.uint32(26).string(message.explorerUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderTrackingInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderTrackingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.providerName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.explorerUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderTrackingInfo {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      providerName: isSet(object.providerName) ? globalThis.String(object.providerName) : "",
      explorerUrl: isSet(object.explorerUrl) ? globalThis.String(object.explorerUrl) : "",
    };
  },

  toJSON(message: ProviderTrackingInfo): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.providerName !== "") {
      obj.providerName = message.providerName;
    }
    if (message.explorerUrl !== "") {
      obj.explorerUrl = message.explorerUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderTrackingInfo>, I>>(base?: I): ProviderTrackingInfo {
    return ProviderTrackingInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderTrackingInfo>, I>>(object: I): ProviderTrackingInfo {
    const message = createBaseProviderTrackingInfo();
    message.requestId = object.requestId ?? "";
    message.providerName = object.providerName ?? "";
    message.explorerUrl = object.explorerUrl ?? "";
    return message;
  },
};

function createBaseGetProviderTrackingStatusRequest(): GetProviderTrackingStatusRequest {
  return { requestId: "", transactionId: "" };
}

export const GetProviderTrackingStatusRequest = {
  encode(message: GetProviderTrackingStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProviderTrackingStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProviderTrackingStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProviderTrackingStatusRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
    };
  },

  toJSON(message: GetProviderTrackingStatusRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProviderTrackingStatusRequest>, I>>(
    base?: I,
  ): GetProviderTrackingStatusRequest {
    return GetProviderTrackingStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProviderTrackingStatusRequest>, I>>(
    object: I,
  ): GetProviderTrackingStatusRequest {
    const message = createBaseGetProviderTrackingStatusRequest();
    message.requestId = object.requestId ?? "";
    message.transactionId = object.transactionId ?? "";
    return message;
  },
};

function createBaseProviderTrackingStatus(): ProviderTrackingStatus {
  return { requestId: "", transactionId: "", providerName: "", explorerUrl: "", status: 0 };
}

export const ProviderTrackingStatus = {
  encode(message: ProviderTrackingStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.providerName !== "") {
      writer.uint32(26).string(message.providerName);
    }
    if (message.explorerUrl !== "") {
      writer.uint32(34).string(message.explorerUrl);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderTrackingStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderTrackingStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.providerName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.explorerUrl = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderTrackingStatus {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      providerName: isSet(object.providerName) ? globalThis.String(object.providerName) : "",
      explorerUrl: isSet(object.explorerUrl) ? globalThis.String(object.explorerUrl) : "",
      status: isSet(object.status) ? providerStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: ProviderTrackingStatus): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.providerName !== "") {
      obj.providerName = message.providerName;
    }
    if (message.explorerUrl !== "") {
      obj.explorerUrl = message.explorerUrl;
    }
    if (message.status !== 0) {
      obj.status = providerStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderTrackingStatus>, I>>(base?: I): ProviderTrackingStatus {
    return ProviderTrackingStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderTrackingStatus>, I>>(object: I): ProviderTrackingStatus {
    const message = createBaseProviderTrackingStatus();
    message.requestId = object.requestId ?? "";
    message.transactionId = object.transactionId ?? "";
    message.providerName = object.providerName ?? "";
    message.explorerUrl = object.explorerUrl ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGetProviderTrackingStatusResponse(): GetProviderTrackingStatusResponse {
  return { trackingStatus: undefined };
}

export const GetProviderTrackingStatusResponse = {
  encode(message: GetProviderTrackingStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.trackingStatus !== undefined) {
      ProviderTrackingStatus.encode(message.trackingStatus, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProviderTrackingStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProviderTrackingStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trackingStatus = ProviderTrackingStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProviderTrackingStatusResponse {
    return {
      trackingStatus: isSet(object.trackingStatus) ? ProviderTrackingStatus.fromJSON(object.trackingStatus) : undefined,
    };
  },

  toJSON(message: GetProviderTrackingStatusResponse): unknown {
    const obj: any = {};
    if (message.trackingStatus !== undefined) {
      obj.trackingStatus = ProviderTrackingStatus.toJSON(message.trackingStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProviderTrackingStatusResponse>, I>>(
    base?: I,
  ): GetProviderTrackingStatusResponse {
    return GetProviderTrackingStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProviderTrackingStatusResponse>, I>>(
    object: I,
  ): GetProviderTrackingStatusResponse {
    const message = createBaseGetProviderTrackingStatusResponse();
    message.trackingStatus = (object.trackingStatus !== undefined && object.trackingStatus !== null)
      ? ProviderTrackingStatus.fromPartial(object.trackingStatus)
      : undefined;
    return message;
  },
};

function createBaseBorrowTokensRequest(): BorrowTokensRequest {
  return { tokenUid: undefined, amount: "", borrowerWalletAddress: "" };
}

export const BorrowTokensRequest = {
  encode(message: BorrowTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.borrowerWalletAddress !== "") {
      writer.uint32(34).string(message.borrowerWalletAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BorrowTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorrowTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.borrowerWalletAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BorrowTokensRequest {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      borrowerWalletAddress: isSet(object.borrowerWalletAddress) ? globalThis.String(object.borrowerWalletAddress) : "",
    };
  },

  toJSON(message: BorrowTokensRequest): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.borrowerWalletAddress !== "") {
      obj.borrowerWalletAddress = message.borrowerWalletAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BorrowTokensRequest>, I>>(base?: I): BorrowTokensRequest {
    return BorrowTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BorrowTokensRequest>, I>>(object: I): BorrowTokensRequest {
    const message = createBaseBorrowTokensRequest();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.amount = object.amount ?? "";
    message.borrowerWalletAddress = object.borrowerWalletAddress ?? "";
    return message;
  },
};

function createBaseBorrowTokensResponse(): BorrowTokensResponse {
  return {
    currentBorrowApy: "",
    liquidationThreshold: "",
    feeBreakdown: undefined,
    transactions: [],
    error: undefined,
  };
}

export const BorrowTokensResponse = {
  encode(message: BorrowTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currentBorrowApy !== "") {
      writer.uint32(10).string(message.currentBorrowApy);
    }
    if (message.liquidationThreshold !== "") {
      writer.uint32(18).string(message.liquidationThreshold);
    }
    if (message.feeBreakdown !== undefined) {
      FeeBreakdown.encode(message.feeBreakdown, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.transactions) {
      TransactionPlan.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.error !== undefined) {
      TransactionPlanError.encode(message.error, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BorrowTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorrowTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentBorrowApy = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.liquidationThreshold = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeBreakdown = FeeBreakdown.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactions.push(TransactionPlan.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = TransactionPlanError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BorrowTokensResponse {
    return {
      currentBorrowApy: isSet(object.currentBorrowApy) ? globalThis.String(object.currentBorrowApy) : "",
      liquidationThreshold: isSet(object.liquidationThreshold) ? globalThis.String(object.liquidationThreshold) : "",
      feeBreakdown: isSet(object.feeBreakdown) ? FeeBreakdown.fromJSON(object.feeBreakdown) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionPlan.fromJSON(e))
        : [],
      error: isSet(object.error) ? TransactionPlanError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BorrowTokensResponse): unknown {
    const obj: any = {};
    if (message.currentBorrowApy !== "") {
      obj.currentBorrowApy = message.currentBorrowApy;
    }
    if (message.liquidationThreshold !== "") {
      obj.liquidationThreshold = message.liquidationThreshold;
    }
    if (message.feeBreakdown !== undefined) {
      obj.feeBreakdown = FeeBreakdown.toJSON(message.feeBreakdown);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionPlan.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = TransactionPlanError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BorrowTokensResponse>, I>>(base?: I): BorrowTokensResponse {
    return BorrowTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BorrowTokensResponse>, I>>(object: I): BorrowTokensResponse {
    const message = createBaseBorrowTokensResponse();
    message.currentBorrowApy = object.currentBorrowApy ?? "";
    message.liquidationThreshold = object.liquidationThreshold ?? "";
    message.feeBreakdown = (object.feeBreakdown !== undefined && object.feeBreakdown !== null)
      ? FeeBreakdown.fromPartial(object.feeBreakdown)
      : undefined;
    message.transactions = object.transactions?.map((e) => TransactionPlan.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? TransactionPlanError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseGetWalletPositionsRequest(): GetWalletPositionsRequest {
  return { walletAddress: "" };
}

export const GetWalletPositionsRequest = {
  encode(message: GetWalletPositionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.walletAddress !== "") {
      writer.uint32(10).string(message.walletAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletPositionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletPositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.walletAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletPositionsRequest {
    return { walletAddress: isSet(object.walletAddress) ? globalThis.String(object.walletAddress) : "" };
  },

  toJSON(message: GetWalletPositionsRequest): unknown {
    const obj: any = {};
    if (message.walletAddress !== "") {
      obj.walletAddress = message.walletAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWalletPositionsRequest>, I>>(base?: I): GetWalletPositionsRequest {
    return GetWalletPositionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWalletPositionsRequest>, I>>(object: I): GetWalletPositionsRequest {
    const message = createBaseGetWalletPositionsRequest();
    message.walletAddress = object.walletAddress ?? "";
    return message;
  },
};

function createBaseGetWalletPositionsResponse(): GetWalletPositionsResponse {
  return { positions: [] };
}

export const GetWalletPositionsResponse = {
  encode(message: GetWalletPositionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.positions) {
      WalletPosition.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletPositionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletPositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.positions.push(WalletPosition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletPositionsResponse {
    return {
      positions: globalThis.Array.isArray(object?.positions)
        ? object.positions.map((e: any) => WalletPosition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetWalletPositionsResponse): unknown {
    const obj: any = {};
    if (message.positions?.length) {
      obj.positions = message.positions.map((e) => WalletPosition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWalletPositionsResponse>, I>>(base?: I): GetWalletPositionsResponse {
    return GetWalletPositionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWalletPositionsResponse>, I>>(object: I): GetWalletPositionsResponse {
    const message = createBaseGetWalletPositionsResponse();
    message.positions = object.positions?.map((e) => WalletPosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWalletPosition(): WalletPosition {
  return { lendingPosition: undefined };
}

export const WalletPosition = {
  encode(message: WalletPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lendingPosition !== undefined) {
      LendingPosition.encode(message.lendingPosition, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WalletPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lendingPosition = LendingPosition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletPosition {
    return {
      lendingPosition: isSet(object.lendingPosition) ? LendingPosition.fromJSON(object.lendingPosition) : undefined,
    };
  },

  toJSON(message: WalletPosition): unknown {
    const obj: any = {};
    if (message.lendingPosition !== undefined) {
      obj.lendingPosition = LendingPosition.toJSON(message.lendingPosition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletPosition>, I>>(base?: I): WalletPosition {
    return WalletPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletPosition>, I>>(object: I): WalletPosition {
    const message = createBaseWalletPosition();
    message.lendingPosition = (object.lendingPosition !== undefined && object.lendingPosition !== null)
      ? LendingPosition.fromPartial(object.lendingPosition)
      : undefined;
    return message;
  },
};

function createBaseBorrowPosition(): BorrowPosition {
  return {
    borrowerWalletAddress: "",
    totalLiquidityUsd: "",
    totalCollateralUsd: "",
    totalBorrowsUsd: "",
    netWorthUsd: "",
    healthFactor: "",
    positions: [],
  };
}

export const BorrowPosition = {
  encode(message: BorrowPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.borrowerWalletAddress !== "") {
      writer.uint32(10).string(message.borrowerWalletAddress);
    }
    if (message.totalLiquidityUsd !== "") {
      writer.uint32(18).string(message.totalLiquidityUsd);
    }
    if (message.totalCollateralUsd !== "") {
      writer.uint32(26).string(message.totalCollateralUsd);
    }
    if (message.totalBorrowsUsd !== "") {
      writer.uint32(34).string(message.totalBorrowsUsd);
    }
    if (message.netWorthUsd !== "") {
      writer.uint32(42).string(message.netWorthUsd);
    }
    if (message.healthFactor !== "") {
      writer.uint32(50).string(message.healthFactor);
    }
    for (const v of message.positions) {
      TokenPosition.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BorrowPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorrowPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.borrowerWalletAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.totalLiquidityUsd = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.totalCollateralUsd = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totalBorrowsUsd = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.netWorthUsd = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.healthFactor = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.positions.push(TokenPosition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BorrowPosition {
    return {
      borrowerWalletAddress: isSet(object.borrowerWalletAddress) ? globalThis.String(object.borrowerWalletAddress) : "",
      totalLiquidityUsd: isSet(object.totalLiquidityUsd) ? globalThis.String(object.totalLiquidityUsd) : "",
      totalCollateralUsd: isSet(object.totalCollateralUsd) ? globalThis.String(object.totalCollateralUsd) : "",
      totalBorrowsUsd: isSet(object.totalBorrowsUsd) ? globalThis.String(object.totalBorrowsUsd) : "",
      netWorthUsd: isSet(object.netWorthUsd) ? globalThis.String(object.netWorthUsd) : "",
      healthFactor: isSet(object.healthFactor) ? globalThis.String(object.healthFactor) : "",
      positions: globalThis.Array.isArray(object?.positions)
        ? object.positions.map((e: any) => TokenPosition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BorrowPosition): unknown {
    const obj: any = {};
    if (message.borrowerWalletAddress !== "") {
      obj.borrowerWalletAddress = message.borrowerWalletAddress;
    }
    if (message.totalLiquidityUsd !== "") {
      obj.totalLiquidityUsd = message.totalLiquidityUsd;
    }
    if (message.totalCollateralUsd !== "") {
      obj.totalCollateralUsd = message.totalCollateralUsd;
    }
    if (message.totalBorrowsUsd !== "") {
      obj.totalBorrowsUsd = message.totalBorrowsUsd;
    }
    if (message.netWorthUsd !== "") {
      obj.netWorthUsd = message.netWorthUsd;
    }
    if (message.healthFactor !== "") {
      obj.healthFactor = message.healthFactor;
    }
    if (message.positions?.length) {
      obj.positions = message.positions.map((e) => TokenPosition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BorrowPosition>, I>>(base?: I): BorrowPosition {
    return BorrowPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BorrowPosition>, I>>(object: I): BorrowPosition {
    const message = createBaseBorrowPosition();
    message.borrowerWalletAddress = object.borrowerWalletAddress ?? "";
    message.totalLiquidityUsd = object.totalLiquidityUsd ?? "";
    message.totalCollateralUsd = object.totalCollateralUsd ?? "";
    message.totalBorrowsUsd = object.totalBorrowsUsd ?? "";
    message.netWorthUsd = object.netWorthUsd ?? "";
    message.healthFactor = object.healthFactor ?? "";
    message.positions = object.positions?.map((e) => TokenPosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenPosition(): TokenPosition {
  return { underlyingToken: undefined, borrowRate: "", supplyBalance: "", borrowBalance: "", valueUsd: "" };
}

export const TokenPosition = {
  encode(message: TokenPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.underlyingToken !== undefined) {
      Token.encode(message.underlyingToken, writer.uint32(10).fork()).ldelim();
    }
    if (message.borrowRate !== "") {
      writer.uint32(18).string(message.borrowRate);
    }
    if (message.supplyBalance !== "") {
      writer.uint32(26).string(message.supplyBalance);
    }
    if (message.borrowBalance !== "") {
      writer.uint32(34).string(message.borrowBalance);
    }
    if (message.valueUsd !== "") {
      writer.uint32(42).string(message.valueUsd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.underlyingToken = Token.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.borrowRate = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.supplyBalance = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.borrowBalance = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.valueUsd = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenPosition {
    return {
      underlyingToken: isSet(object.underlyingToken) ? Token.fromJSON(object.underlyingToken) : undefined,
      borrowRate: isSet(object.borrowRate) ? globalThis.String(object.borrowRate) : "",
      supplyBalance: isSet(object.supplyBalance) ? globalThis.String(object.supplyBalance) : "",
      borrowBalance: isSet(object.borrowBalance) ? globalThis.String(object.borrowBalance) : "",
      valueUsd: isSet(object.valueUsd) ? globalThis.String(object.valueUsd) : "",
    };
  },

  toJSON(message: TokenPosition): unknown {
    const obj: any = {};
    if (message.underlyingToken !== undefined) {
      obj.underlyingToken = Token.toJSON(message.underlyingToken);
    }
    if (message.borrowRate !== "") {
      obj.borrowRate = message.borrowRate;
    }
    if (message.supplyBalance !== "") {
      obj.supplyBalance = message.supplyBalance;
    }
    if (message.borrowBalance !== "") {
      obj.borrowBalance = message.borrowBalance;
    }
    if (message.valueUsd !== "") {
      obj.valueUsd = message.valueUsd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenPosition>, I>>(base?: I): TokenPosition {
    return TokenPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenPosition>, I>>(object: I): TokenPosition {
    const message = createBaseTokenPosition();
    message.underlyingToken = (object.underlyingToken !== undefined && object.underlyingToken !== null)
      ? Token.fromPartial(object.underlyingToken)
      : undefined;
    message.borrowRate = object.borrowRate ?? "";
    message.supplyBalance = object.supplyBalance ?? "";
    message.borrowBalance = object.borrowBalance ?? "";
    message.valueUsd = object.valueUsd ?? "";
    return message;
  },
};

function createBaseLendingPosition(): LendingPosition {
  return {
    userReserves: [],
    totalLiquidityUsd: "",
    totalCollateralUsd: "",
    totalBorrowsUsd: "",
    netWorthUsd: "",
    availableBorrowsUsd: "",
    currentLoanToValue: "",
    currentLiquidationThreshold: "",
    healthFactor: "",
  };
}

export const LendingPosition = {
  encode(message: LendingPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.userReserves) {
      LendTokenDetail.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalLiquidityUsd !== "") {
      writer.uint32(18).string(message.totalLiquidityUsd);
    }
    if (message.totalCollateralUsd !== "") {
      writer.uint32(26).string(message.totalCollateralUsd);
    }
    if (message.totalBorrowsUsd !== "") {
      writer.uint32(34).string(message.totalBorrowsUsd);
    }
    if (message.netWorthUsd !== "") {
      writer.uint32(42).string(message.netWorthUsd);
    }
    if (message.availableBorrowsUsd !== "") {
      writer.uint32(50).string(message.availableBorrowsUsd);
    }
    if (message.currentLoanToValue !== "") {
      writer.uint32(58).string(message.currentLoanToValue);
    }
    if (message.currentLiquidationThreshold !== "") {
      writer.uint32(66).string(message.currentLiquidationThreshold);
    }
    if (message.healthFactor !== "") {
      writer.uint32(74).string(message.healthFactor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendingPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendingPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userReserves.push(LendTokenDetail.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.totalLiquidityUsd = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.totalCollateralUsd = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totalBorrowsUsd = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.netWorthUsd = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.availableBorrowsUsd = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currentLoanToValue = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currentLiquidationThreshold = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.healthFactor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendingPosition {
    return {
      userReserves: globalThis.Array.isArray(object?.userReserves)
        ? object.userReserves.map((e: any) => LendTokenDetail.fromJSON(e))
        : [],
      totalLiquidityUsd: isSet(object.totalLiquidityUsd) ? globalThis.String(object.totalLiquidityUsd) : "",
      totalCollateralUsd: isSet(object.totalCollateralUsd) ? globalThis.String(object.totalCollateralUsd) : "",
      totalBorrowsUsd: isSet(object.totalBorrowsUsd) ? globalThis.String(object.totalBorrowsUsd) : "",
      netWorthUsd: isSet(object.netWorthUsd) ? globalThis.String(object.netWorthUsd) : "",
      availableBorrowsUsd: isSet(object.availableBorrowsUsd) ? globalThis.String(object.availableBorrowsUsd) : "",
      currentLoanToValue: isSet(object.currentLoanToValue) ? globalThis.String(object.currentLoanToValue) : "",
      currentLiquidationThreshold: isSet(object.currentLiquidationThreshold)
        ? globalThis.String(object.currentLiquidationThreshold)
        : "",
      healthFactor: isSet(object.healthFactor) ? globalThis.String(object.healthFactor) : "",
    };
  },

  toJSON(message: LendingPosition): unknown {
    const obj: any = {};
    if (message.userReserves?.length) {
      obj.userReserves = message.userReserves.map((e) => LendTokenDetail.toJSON(e));
    }
    if (message.totalLiquidityUsd !== "") {
      obj.totalLiquidityUsd = message.totalLiquidityUsd;
    }
    if (message.totalCollateralUsd !== "") {
      obj.totalCollateralUsd = message.totalCollateralUsd;
    }
    if (message.totalBorrowsUsd !== "") {
      obj.totalBorrowsUsd = message.totalBorrowsUsd;
    }
    if (message.netWorthUsd !== "") {
      obj.netWorthUsd = message.netWorthUsd;
    }
    if (message.availableBorrowsUsd !== "") {
      obj.availableBorrowsUsd = message.availableBorrowsUsd;
    }
    if (message.currentLoanToValue !== "") {
      obj.currentLoanToValue = message.currentLoanToValue;
    }
    if (message.currentLiquidationThreshold !== "") {
      obj.currentLiquidationThreshold = message.currentLiquidationThreshold;
    }
    if (message.healthFactor !== "") {
      obj.healthFactor = message.healthFactor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LendingPosition>, I>>(base?: I): LendingPosition {
    return LendingPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LendingPosition>, I>>(object: I): LendingPosition {
    const message = createBaseLendingPosition();
    message.userReserves = object.userReserves?.map((e) => LendTokenDetail.fromPartial(e)) || [];
    message.totalLiquidityUsd = object.totalLiquidityUsd ?? "";
    message.totalCollateralUsd = object.totalCollateralUsd ?? "";
    message.totalBorrowsUsd = object.totalBorrowsUsd ?? "";
    message.netWorthUsd = object.netWorthUsd ?? "";
    message.availableBorrowsUsd = object.availableBorrowsUsd ?? "";
    message.currentLoanToValue = object.currentLoanToValue ?? "";
    message.currentLiquidationThreshold = object.currentLiquidationThreshold ?? "";
    message.healthFactor = object.healthFactor ?? "";
    return message;
  },
};

function createBaseLendTokenDetail(): LendTokenDetail {
  return {
    token: undefined,
    underlyingBalance: "",
    underlyingBalanceUsd: "",
    variableBorrows: "",
    variableBorrowsUsd: "",
    totalBorrows: "",
    totalBorrowsUsd: "",
  };
}

export const LendTokenDetail = {
  encode(message: LendTokenDetail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== undefined) {
      Token.encode(message.token, writer.uint32(10).fork()).ldelim();
    }
    if (message.underlyingBalance !== "") {
      writer.uint32(18).string(message.underlyingBalance);
    }
    if (message.underlyingBalanceUsd !== "") {
      writer.uint32(26).string(message.underlyingBalanceUsd);
    }
    if (message.variableBorrows !== "") {
      writer.uint32(34).string(message.variableBorrows);
    }
    if (message.variableBorrowsUsd !== "") {
      writer.uint32(42).string(message.variableBorrowsUsd);
    }
    if (message.totalBorrows !== "") {
      writer.uint32(50).string(message.totalBorrows);
    }
    if (message.totalBorrowsUsd !== "") {
      writer.uint32(58).string(message.totalBorrowsUsd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendTokenDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendTokenDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = Token.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.underlyingBalance = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.underlyingBalanceUsd = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.variableBorrows = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.variableBorrowsUsd = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.totalBorrows = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.totalBorrowsUsd = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendTokenDetail {
    return {
      token: isSet(object.token) ? Token.fromJSON(object.token) : undefined,
      underlyingBalance: isSet(object.underlyingBalance) ? globalThis.String(object.underlyingBalance) : "",
      underlyingBalanceUsd: isSet(object.underlyingBalanceUsd) ? globalThis.String(object.underlyingBalanceUsd) : "",
      variableBorrows: isSet(object.variableBorrows) ? globalThis.String(object.variableBorrows) : "",
      variableBorrowsUsd: isSet(object.variableBorrowsUsd) ? globalThis.String(object.variableBorrowsUsd) : "",
      totalBorrows: isSet(object.totalBorrows) ? globalThis.String(object.totalBorrows) : "",
      totalBorrowsUsd: isSet(object.totalBorrowsUsd) ? globalThis.String(object.totalBorrowsUsd) : "",
    };
  },

  toJSON(message: LendTokenDetail): unknown {
    const obj: any = {};
    if (message.token !== undefined) {
      obj.token = Token.toJSON(message.token);
    }
    if (message.underlyingBalance !== "") {
      obj.underlyingBalance = message.underlyingBalance;
    }
    if (message.underlyingBalanceUsd !== "") {
      obj.underlyingBalanceUsd = message.underlyingBalanceUsd;
    }
    if (message.variableBorrows !== "") {
      obj.variableBorrows = message.variableBorrows;
    }
    if (message.variableBorrowsUsd !== "") {
      obj.variableBorrowsUsd = message.variableBorrowsUsd;
    }
    if (message.totalBorrows !== "") {
      obj.totalBorrows = message.totalBorrows;
    }
    if (message.totalBorrowsUsd !== "") {
      obj.totalBorrowsUsd = message.totalBorrowsUsd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LendTokenDetail>, I>>(base?: I): LendTokenDetail {
    return LendTokenDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LendTokenDetail>, I>>(object: I): LendTokenDetail {
    const message = createBaseLendTokenDetail();
    message.token = (object.token !== undefined && object.token !== null) ? Token.fromPartial(object.token) : undefined;
    message.underlyingBalance = object.underlyingBalance ?? "";
    message.underlyingBalanceUsd = object.underlyingBalanceUsd ?? "";
    message.variableBorrows = object.variableBorrows ?? "";
    message.variableBorrowsUsd = object.variableBorrowsUsd ?? "";
    message.totalBorrows = object.totalBorrows ?? "";
    message.totalBorrowsUsd = object.totalBorrowsUsd ?? "";
    return message;
  },
};

function createBaseRepayTokensRequest(): RepayTokensRequest {
  return { tokenUid: undefined, amount: "", borrowerWalletAddress: "" };
}

export const RepayTokensRequest = {
  encode(message: RepayTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.borrowerWalletAddress !== "") {
      writer.uint32(34).string(message.borrowerWalletAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RepayTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepayTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.borrowerWalletAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepayTokensRequest {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      borrowerWalletAddress: isSet(object.borrowerWalletAddress) ? globalThis.String(object.borrowerWalletAddress) : "",
    };
  },

  toJSON(message: RepayTokensRequest): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.borrowerWalletAddress !== "") {
      obj.borrowerWalletAddress = message.borrowerWalletAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RepayTokensRequest>, I>>(base?: I): RepayTokensRequest {
    return RepayTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RepayTokensRequest>, I>>(object: I): RepayTokensRequest {
    const message = createBaseRepayTokensRequest();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.amount = object.amount ?? "";
    message.borrowerWalletAddress = object.borrowerWalletAddress ?? "";
    return message;
  },
};

function createBaseRepayTokensResponse(): RepayTokensResponse {
  return {
    tokenUid: undefined,
    amount: "",
    borrowerWalletAddress: "",
    feeBreakdown: undefined,
    transactions: [],
    error: undefined,
  };
}

export const RepayTokensResponse = {
  encode(message: RepayTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.borrowerWalletAddress !== "") {
      writer.uint32(34).string(message.borrowerWalletAddress);
    }
    if (message.feeBreakdown !== undefined) {
      FeeBreakdown.encode(message.feeBreakdown, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.transactions) {
      TransactionPlan.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.error !== undefined) {
      TransactionPlanError.encode(message.error, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RepayTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepayTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.borrowerWalletAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeBreakdown = FeeBreakdown.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactions.push(TransactionPlan.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = TransactionPlanError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepayTokensResponse {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      borrowerWalletAddress: isSet(object.borrowerWalletAddress) ? globalThis.String(object.borrowerWalletAddress) : "",
      feeBreakdown: isSet(object.feeBreakdown) ? FeeBreakdown.fromJSON(object.feeBreakdown) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionPlan.fromJSON(e))
        : [],
      error: isSet(object.error) ? TransactionPlanError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RepayTokensResponse): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.borrowerWalletAddress !== "") {
      obj.borrowerWalletAddress = message.borrowerWalletAddress;
    }
    if (message.feeBreakdown !== undefined) {
      obj.feeBreakdown = FeeBreakdown.toJSON(message.feeBreakdown);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionPlan.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = TransactionPlanError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RepayTokensResponse>, I>>(base?: I): RepayTokensResponse {
    return RepayTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RepayTokensResponse>, I>>(object: I): RepayTokensResponse {
    const message = createBaseRepayTokensResponse();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.amount = object.amount ?? "";
    message.borrowerWalletAddress = object.borrowerWalletAddress ?? "";
    message.feeBreakdown = (object.feeBreakdown !== undefined && object.feeBreakdown !== null)
      ? FeeBreakdown.fromPartial(object.feeBreakdown)
      : undefined;
    message.transactions = object.transactions?.map((e) => TransactionPlan.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? TransactionPlanError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseSupplyTokensRequest(): SupplyTokensRequest {
  return { tokenUid: undefined, amount: "", supplierWalletAddress: "" };
}

export const SupplyTokensRequest = {
  encode(message: SupplyTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.supplierWalletAddress !== "") {
      writer.uint32(34).string(message.supplierWalletAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SupplyTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupplyTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.supplierWalletAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupplyTokensRequest {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      supplierWalletAddress: isSet(object.supplierWalletAddress) ? globalThis.String(object.supplierWalletAddress) : "",
    };
  },

  toJSON(message: SupplyTokensRequest): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.supplierWalletAddress !== "") {
      obj.supplierWalletAddress = message.supplierWalletAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SupplyTokensRequest>, I>>(base?: I): SupplyTokensRequest {
    return SupplyTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SupplyTokensRequest>, I>>(object: I): SupplyTokensRequest {
    const message = createBaseSupplyTokensRequest();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.amount = object.amount ?? "";
    message.supplierWalletAddress = object.supplierWalletAddress ?? "";
    return message;
  },
};

function createBaseSupplyTokensResponse(): SupplyTokensResponse {
  return {
    tokenUid: undefined,
    amount: "",
    supplierWalletAddress: "",
    feeBreakdown: undefined,
    transactions: [],
    error: undefined,
  };
}

export const SupplyTokensResponse = {
  encode(message: SupplyTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.supplierWalletAddress !== "") {
      writer.uint32(34).string(message.supplierWalletAddress);
    }
    if (message.feeBreakdown !== undefined) {
      FeeBreakdown.encode(message.feeBreakdown, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.transactions) {
      TransactionPlan.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.error !== undefined) {
      TransactionPlanError.encode(message.error, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SupplyTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupplyTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.supplierWalletAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeBreakdown = FeeBreakdown.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactions.push(TransactionPlan.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = TransactionPlanError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupplyTokensResponse {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      supplierWalletAddress: isSet(object.supplierWalletAddress) ? globalThis.String(object.supplierWalletAddress) : "",
      feeBreakdown: isSet(object.feeBreakdown) ? FeeBreakdown.fromJSON(object.feeBreakdown) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionPlan.fromJSON(e))
        : [],
      error: isSet(object.error) ? TransactionPlanError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: SupplyTokensResponse): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.supplierWalletAddress !== "") {
      obj.supplierWalletAddress = message.supplierWalletAddress;
    }
    if (message.feeBreakdown !== undefined) {
      obj.feeBreakdown = FeeBreakdown.toJSON(message.feeBreakdown);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionPlan.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = TransactionPlanError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SupplyTokensResponse>, I>>(base?: I): SupplyTokensResponse {
    return SupplyTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SupplyTokensResponse>, I>>(object: I): SupplyTokensResponse {
    const message = createBaseSupplyTokensResponse();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.amount = object.amount ?? "";
    message.supplierWalletAddress = object.supplierWalletAddress ?? "";
    message.feeBreakdown = (object.feeBreakdown !== undefined && object.feeBreakdown !== null)
      ? FeeBreakdown.fromPartial(object.feeBreakdown)
      : undefined;
    message.transactions = object.transactions?.map((e) => TransactionPlan.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? TransactionPlanError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseWithdrawTokensRequest(): WithdrawTokensRequest {
  return { tokenUid: undefined, amount: "", lenderWalletAddress: "" };
}

export const WithdrawTokensRequest = {
  encode(message: WithdrawTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.lenderWalletAddress !== "") {
      writer.uint32(34).string(message.lenderWalletAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WithdrawTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lenderWalletAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawTokensRequest {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      lenderWalletAddress: isSet(object.lenderWalletAddress) ? globalThis.String(object.lenderWalletAddress) : "",
    };
  },

  toJSON(message: WithdrawTokensRequest): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.lenderWalletAddress !== "") {
      obj.lenderWalletAddress = message.lenderWalletAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawTokensRequest>, I>>(base?: I): WithdrawTokensRequest {
    return WithdrawTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawTokensRequest>, I>>(object: I): WithdrawTokensRequest {
    const message = createBaseWithdrawTokensRequest();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.amount = object.amount ?? "";
    message.lenderWalletAddress = object.lenderWalletAddress ?? "";
    return message;
  },
};

function createBaseWithdrawTokensResponse(): WithdrawTokensResponse {
  return {
    tokenUid: undefined,
    amount: "",
    lenderWalletAddress: "",
    feeBreakdown: undefined,
    transactions: [],
    error: undefined,
  };
}

export const WithdrawTokensResponse = {
  encode(message: WithdrawTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.lenderWalletAddress !== "") {
      writer.uint32(34).string(message.lenderWalletAddress);
    }
    if (message.feeBreakdown !== undefined) {
      FeeBreakdown.encode(message.feeBreakdown, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.transactions) {
      TransactionPlan.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.error !== undefined) {
      TransactionPlanError.encode(message.error, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WithdrawTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lenderWalletAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeBreakdown = FeeBreakdown.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactions.push(TransactionPlan.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = TransactionPlanError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawTokensResponse {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      lenderWalletAddress: isSet(object.lenderWalletAddress) ? globalThis.String(object.lenderWalletAddress) : "",
      feeBreakdown: isSet(object.feeBreakdown) ? FeeBreakdown.fromJSON(object.feeBreakdown) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionPlan.fromJSON(e))
        : [],
      error: isSet(object.error) ? TransactionPlanError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: WithdrawTokensResponse): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.lenderWalletAddress !== "") {
      obj.lenderWalletAddress = message.lenderWalletAddress;
    }
    if (message.feeBreakdown !== undefined) {
      obj.feeBreakdown = FeeBreakdown.toJSON(message.feeBreakdown);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionPlan.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = TransactionPlanError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawTokensResponse>, I>>(base?: I): WithdrawTokensResponse {
    return WithdrawTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawTokensResponse>, I>>(object: I): WithdrawTokensResponse {
    const message = createBaseWithdrawTokensResponse();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.amount = object.amount ?? "";
    message.lenderWalletAddress = object.lenderWalletAddress ?? "";
    message.feeBreakdown = (object.feeBreakdown !== undefined && object.feeBreakdown !== null)
      ? FeeBreakdown.fromPartial(object.feeBreakdown)
      : undefined;
    message.transactions = object.transactions?.map((e) => TransactionPlan.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? TransactionPlanError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseGetLendingUserSummaryRequest(): GetLendingUserSummaryRequest {
  return { userAddress: "" };
}

export const GetLendingUserSummaryRequest = {
  encode(message: GetLendingUserSummaryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userAddress !== "") {
      writer.uint32(10).string(message.userAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLendingUserSummaryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLendingUserSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLendingUserSummaryRequest {
    return { userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "" };
  },

  toJSON(message: GetLendingUserSummaryRequest): unknown {
    const obj: any = {};
    if (message.userAddress !== "") {
      obj.userAddress = message.userAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLendingUserSummaryRequest>, I>>(base?: I): GetLendingUserSummaryRequest {
    return GetLendingUserSummaryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLendingUserSummaryRequest>, I>>(object: I): GetLendingUserSummaryRequest {
    const message = createBaseGetLendingUserSummaryRequest();
    message.userAddress = object.userAddress ?? "";
    return message;
  },
};

function createBaseLendingReserve(): LendingReserve {
  return {
    tokenUid: undefined,
    symbol: "",
    decimals: 0,
    supplyRate: "",
    borrowRate: "",
    reserveFactor: "",
    reserveLiquidationThreshold: "",
  };
}

export const LendingReserve = {
  encode(message: LendingReserve, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUid !== undefined) {
      TokenIdentifier.encode(message.tokenUid, writer.uint32(10).fork()).ldelim();
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(24).int32(message.decimals);
    }
    if (message.supplyRate !== "") {
      writer.uint32(34).string(message.supplyRate);
    }
    if (message.borrowRate !== "") {
      writer.uint32(42).string(message.borrowRate);
    }
    if (message.reserveFactor !== "") {
      writer.uint32(50).string(message.reserveFactor);
    }
    if (message.reserveLiquidationThreshold !== "") {
      writer.uint32(58).string(message.reserveLiquidationThreshold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendingReserve {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendingReserve();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenUid = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.decimals = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.supplyRate = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.borrowRate = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reserveFactor = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.reserveLiquidationThreshold = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendingReserve {
    return {
      tokenUid: isSet(object.tokenUid) ? TokenIdentifier.fromJSON(object.tokenUid) : undefined,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      supplyRate: isSet(object.supplyRate) ? globalThis.String(object.supplyRate) : "",
      borrowRate: isSet(object.borrowRate) ? globalThis.String(object.borrowRate) : "",
      reserveFactor: isSet(object.reserveFactor) ? globalThis.String(object.reserveFactor) : "",
      reserveLiquidationThreshold: isSet(object.reserveLiquidationThreshold)
        ? globalThis.String(object.reserveLiquidationThreshold)
        : "",
    };
  },

  toJSON(message: LendingReserve): unknown {
    const obj: any = {};
    if (message.tokenUid !== undefined) {
      obj.tokenUid = TokenIdentifier.toJSON(message.tokenUid);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.supplyRate !== "") {
      obj.supplyRate = message.supplyRate;
    }
    if (message.borrowRate !== "") {
      obj.borrowRate = message.borrowRate;
    }
    if (message.reserveFactor !== "") {
      obj.reserveFactor = message.reserveFactor;
    }
    if (message.reserveLiquidationThreshold !== "") {
      obj.reserveLiquidationThreshold = message.reserveLiquidationThreshold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LendingReserve>, I>>(base?: I): LendingReserve {
    return LendingReserve.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LendingReserve>, I>>(object: I): LendingReserve {
    const message = createBaseLendingReserve();
    message.tokenUid = (object.tokenUid !== undefined && object.tokenUid !== null)
      ? TokenIdentifier.fromPartial(object.tokenUid)
      : undefined;
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.supplyRate = object.supplyRate ?? "";
    message.borrowRate = object.borrowRate ?? "";
    message.reserveFactor = object.reserveFactor ?? "";
    message.reserveLiquidationThreshold = object.reserveLiquidationThreshold ?? "";
    return message;
  },
};

function createBaseGetLendingReservesResponse(): GetLendingReservesResponse {
  return { reserves: [] };
}

export const GetLendingReservesResponse = {
  encode(message: GetLendingReservesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.reserves) {
      LendingReserve.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLendingReservesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLendingReservesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reserves.push(LendingReserve.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLendingReservesResponse {
    return {
      reserves: globalThis.Array.isArray(object?.reserves)
        ? object.reserves.map((e: any) => LendingReserve.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetLendingReservesResponse): unknown {
    const obj: any = {};
    if (message.reserves?.length) {
      obj.reserves = message.reserves.map((e) => LendingReserve.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLendingReservesResponse>, I>>(base?: I): GetLendingReservesResponse {
    return GetLendingReservesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLendingReservesResponse>, I>>(object: I): GetLendingReservesResponse {
    const message = createBaseGetLendingReservesResponse();
    message.reserves = object.reserves?.map((e) => LendingReserve.fromPartial(e)) || [];
    return message;
  },
};

/**
 * The DataService provides information about chains and tokens.
 *
 * Possible gRPC error codes for these methods:
 * - INVALID_ARGUMENT: The request parameters are malformed or invalid.
 * - NOT_FOUND: The requested resource(s) could not be found.
 * - INTERNAL: An unexpected server-side error occurred.
 * - UNAUTHENTICATED / PERMISSION_DENIED: If authentication or authorization fails.
 */
export type DataServiceService = typeof DataServiceService;
export const DataServiceService = {
  /**
   * Returns a list of supported chains.
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getChains: {
    path: "/ember_agents_onchain.v1.DataService/GetChains",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetChainsRequest) => Buffer.from(GetChainsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetChainsRequest.decode(value),
    responseSerialize: (value: GetChainsResponse) => Buffer.from(GetChainsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetChainsResponse.decode(value),
  },
  /**
   * Returns a list of tokens (potentially filtered by chain or other criteria).
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - NOT_FOUND if no tokens match the request.
   *   - INTERNAL for server-side issues.
   */
  getTokens: {
    path: "/ember_agents_onchain.v1.DataService/GetTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTokensRequest) => Buffer.from(GetTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTokensRequest.decode(value),
    responseSerialize: (value: GetTokensResponse) => Buffer.from(GetTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTokensResponse.decode(value),
  },
  /**
   * Returns a list of capabilities filtered by capability type.
   * Error codes:
   *   - INVALID_ARGUMENT if request parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getCapabilities: {
    path: "/ember_agents_onchain.v1.DataService/GetCapabilities",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCapabilitiesRequest) => Buffer.from(GetCapabilitiesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCapabilitiesRequest.decode(value),
    responseSerialize: (value: GetCapabilitiesResponse) => Buffer.from(GetCapabilitiesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCapabilitiesResponse.decode(value),
  },
} as const;

export interface DataServiceServer extends UntypedServiceImplementation {
  /**
   * Returns a list of supported chains.
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getChains: handleUnaryCall<GetChainsRequest, GetChainsResponse>;
  /**
   * Returns a list of tokens (potentially filtered by chain or other criteria).
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - NOT_FOUND if no tokens match the request.
   *   - INTERNAL for server-side issues.
   */
  getTokens: handleUnaryCall<GetTokensRequest, GetTokensResponse>;
  /**
   * Returns a list of capabilities filtered by capability type.
   * Error codes:
   *   - INVALID_ARGUMENT if request parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getCapabilities: handleUnaryCall<GetCapabilitiesRequest, GetCapabilitiesResponse>;
}

export interface DataServiceClient extends Client {
  /**
   * Returns a list of supported chains.
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getChains(
    request: GetChainsRequest,
    callback: (error: ServiceError | null, response: GetChainsResponse) => void,
  ): ClientUnaryCall;
  getChains(
    request: GetChainsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetChainsResponse) => void,
  ): ClientUnaryCall;
  getChains(
    request: GetChainsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetChainsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns a list of tokens (potentially filtered by chain or other criteria).
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - NOT_FOUND if no tokens match the request.
   *   - INTERNAL for server-side issues.
   */
  getTokens(
    request: GetTokensRequest,
    callback: (error: ServiceError | null, response: GetTokensResponse) => void,
  ): ClientUnaryCall;
  getTokens(
    request: GetTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTokensResponse) => void,
  ): ClientUnaryCall;
  getTokens(
    request: GetTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTokensResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns a list of capabilities filtered by capability type.
   * Error codes:
   *   - INVALID_ARGUMENT if request parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getCapabilities(
    request: GetCapabilitiesRequest,
    callback: (error: ServiceError | null, response: GetCapabilitiesResponse) => void,
  ): ClientUnaryCall;
  getCapabilities(
    request: GetCapabilitiesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCapabilitiesResponse) => void,
  ): ClientUnaryCall;
  getCapabilities(
    request: GetCapabilitiesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCapabilitiesResponse) => void,
  ): ClientUnaryCall;
}

export const DataServiceClient = makeGenericClientConstructor(
  DataServiceService,
  "ember_agents_onchain.v1.DataService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DataServiceClient;
  service: typeof DataServiceService;
  serviceName: string;
};

/** New service for wallet context details. This groups queries related to a wallet's positions and balances. */
export type WalletContextService = typeof WalletContextService;
export const WalletContextService = {
  /**
   * Gets wallet positions for a given wallet address.
   * Currently returns borrow positions; will be extended to include vault positions, lending positions, and token balances in the future.
   */
  getWalletPositions: {
    path: "/ember_agents_onchain.v1.WalletContext/GetWalletPositions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWalletPositionsRequest) =>
      Buffer.from(GetWalletPositionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWalletPositionsRequest.decode(value),
    responseSerialize: (value: GetWalletPositionsResponse) =>
      Buffer.from(GetWalletPositionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWalletPositionsResponse.decode(value),
  },
} as const;

export interface WalletContextServer extends UntypedServiceImplementation {
  /**
   * Gets wallet positions for a given wallet address.
   * Currently returns borrow positions; will be extended to include vault positions, lending positions, and token balances in the future.
   */
  getWalletPositions: handleUnaryCall<GetWalletPositionsRequest, GetWalletPositionsResponse>;
}

export interface WalletContextClient extends Client {
  /**
   * Gets wallet positions for a given wallet address.
   * Currently returns borrow positions; will be extended to include vault positions, lending positions, and token balances in the future.
   */
  getWalletPositions(
    request: GetWalletPositionsRequest,
    callback: (error: ServiceError | null, response: GetWalletPositionsResponse) => void,
  ): ClientUnaryCall;
  getWalletPositions(
    request: GetWalletPositionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWalletPositionsResponse) => void,
  ): ClientUnaryCall;
  getWalletPositions(
    request: GetWalletPositionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWalletPositionsResponse) => void,
  ): ClientUnaryCall;
}

export const WalletContextClient = makeGenericClientConstructor(
  WalletContextService,
  "ember_agents_onchain.v1.WalletContext",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): WalletContextClient;
  service: typeof WalletContextService;
  serviceName: string;
};

/** New service for transaction creation */
export type CreateTransactionService = typeof CreateTransactionService;
export const CreateTransactionService = {
  /**
   * Creates a transaction for swapping tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if tokens or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the swap is not possible
   */
  swapTokens: {
    path: "/ember_agents_onchain.v1.CreateTransaction/SwapTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SwapTokensRequest) => Buffer.from(SwapTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SwapTokensRequest.decode(value),
    responseSerialize: (value: SwapTokensResponse) => Buffer.from(SwapTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SwapTokensResponse.decode(value),
  },
  /**
   * Creates a transaction for borrowing tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if token or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the borrowing transaction is not possible
   */
  borrowTokens: {
    path: "/ember_agents_onchain.v1.CreateTransaction/BorrowTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BorrowTokensRequest) => Buffer.from(BorrowTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BorrowTokensRequest.decode(value),
    responseSerialize: (value: BorrowTokensResponse) => Buffer.from(BorrowTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BorrowTokensResponse.decode(value),
  },
  repayTokens: {
    path: "/ember_agents_onchain.v1.CreateTransaction/RepayTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RepayTokensRequest) => Buffer.from(RepayTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RepayTokensRequest.decode(value),
    responseSerialize: (value: RepayTokensResponse) => Buffer.from(RepayTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RepayTokensResponse.decode(value),
  },
  supplyTokens: {
    path: "/ember_agents_onchain.v1.CreateTransaction/SupplyTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SupplyTokensRequest) => Buffer.from(SupplyTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SupplyTokensRequest.decode(value),
    responseSerialize: (value: SupplyTokensResponse) => Buffer.from(SupplyTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SupplyTokensResponse.decode(value),
  },
  /**
   * Added RPC for withdrawing tokens (removing or retrieving lent tokens)
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if token or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the withdrawal is not possible (e.g., insufficient balance)
   */
  withdrawTokens: {
    path: "/ember_agents_onchain.v1.CreateTransaction/WithdrawTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WithdrawTokensRequest) => Buffer.from(WithdrawTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WithdrawTokensRequest.decode(value),
    responseSerialize: (value: WithdrawTokensResponse) => Buffer.from(WithdrawTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WithdrawTokensResponse.decode(value),
  },
} as const;

export interface CreateTransactionServer extends UntypedServiceImplementation {
  /**
   * Creates a transaction for swapping tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if tokens or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the swap is not possible
   */
  swapTokens: handleUnaryCall<SwapTokensRequest, SwapTokensResponse>;
  /**
   * Creates a transaction for borrowing tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if token or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the borrowing transaction is not possible
   */
  borrowTokens: handleUnaryCall<BorrowTokensRequest, BorrowTokensResponse>;
  repayTokens: handleUnaryCall<RepayTokensRequest, RepayTokensResponse>;
  supplyTokens: handleUnaryCall<SupplyTokensRequest, SupplyTokensResponse>;
  /**
   * Added RPC for withdrawing tokens (removing or retrieving lent tokens)
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if token or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the withdrawal is not possible (e.g., insufficient balance)
   */
  withdrawTokens: handleUnaryCall<WithdrawTokensRequest, WithdrawTokensResponse>;
}

export interface CreateTransactionClient extends Client {
  /**
   * Creates a transaction for swapping tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if tokens or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the swap is not possible
   */
  swapTokens(
    request: SwapTokensRequest,
    callback: (error: ServiceError | null, response: SwapTokensResponse) => void,
  ): ClientUnaryCall;
  swapTokens(
    request: SwapTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SwapTokensResponse) => void,
  ): ClientUnaryCall;
  swapTokens(
    request: SwapTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SwapTokensResponse) => void,
  ): ClientUnaryCall;
  /**
   * Creates a transaction for borrowing tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if token or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the borrowing transaction is not possible
   */
  borrowTokens(
    request: BorrowTokensRequest,
    callback: (error: ServiceError | null, response: BorrowTokensResponse) => void,
  ): ClientUnaryCall;
  borrowTokens(
    request: BorrowTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BorrowTokensResponse) => void,
  ): ClientUnaryCall;
  borrowTokens(
    request: BorrowTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BorrowTokensResponse) => void,
  ): ClientUnaryCall;
  repayTokens(
    request: RepayTokensRequest,
    callback: (error: ServiceError | null, response: RepayTokensResponse) => void,
  ): ClientUnaryCall;
  repayTokens(
    request: RepayTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RepayTokensResponse) => void,
  ): ClientUnaryCall;
  repayTokens(
    request: RepayTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RepayTokensResponse) => void,
  ): ClientUnaryCall;
  supplyTokens(
    request: SupplyTokensRequest,
    callback: (error: ServiceError | null, response: SupplyTokensResponse) => void,
  ): ClientUnaryCall;
  supplyTokens(
    request: SupplyTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SupplyTokensResponse) => void,
  ): ClientUnaryCall;
  supplyTokens(
    request: SupplyTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SupplyTokensResponse) => void,
  ): ClientUnaryCall;
  /**
   * Added RPC for withdrawing tokens (removing or retrieving lent tokens)
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if token or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the withdrawal is not possible (e.g., insufficient balance)
   */
  withdrawTokens(
    request: WithdrawTokensRequest,
    callback: (error: ServiceError | null, response: WithdrawTokensResponse) => void,
  ): ClientUnaryCall;
  withdrawTokens(
    request: WithdrawTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WithdrawTokensResponse) => void,
  ): ClientUnaryCall;
  withdrawTokens(
    request: WithdrawTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WithdrawTokensResponse) => void,
  ): ClientUnaryCall;
}

export const CreateTransactionClient = makeGenericClientConstructor(
  CreateTransactionService,
  "ember_agents_onchain.v1.CreateTransaction",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CreateTransactionClient;
  service: typeof CreateTransactionService;
  serviceName: string;
};

/** New service for transaction execution */
export type TransactionExecutionService = typeof TransactionExecutionService;
export const TransactionExecutionService = {
  /**
   * Gets the tracking status of a transaction
   * Error codes:
   *   - INVALID_ARGUMENT if request parameters are invalid
   *   - NOT_FOUND if the transaction cannot be found
   *   - INTERNAL for server-side issues
   */
  getProviderTrackingStatus: {
    path: "/ember_agents_onchain.v1.TransactionExecution/GetProviderTrackingStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProviderTrackingStatusRequest) =>
      Buffer.from(GetProviderTrackingStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProviderTrackingStatusRequest.decode(value),
    responseSerialize: (value: GetProviderTrackingStatusResponse) =>
      Buffer.from(GetProviderTrackingStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProviderTrackingStatusResponse.decode(value),
  },
} as const;

export interface TransactionExecutionServer extends UntypedServiceImplementation {
  /**
   * Gets the tracking status of a transaction
   * Error codes:
   *   - INVALID_ARGUMENT if request parameters are invalid
   *   - NOT_FOUND if the transaction cannot be found
   *   - INTERNAL for server-side issues
   */
  getProviderTrackingStatus: handleUnaryCall<GetProviderTrackingStatusRequest, GetProviderTrackingStatusResponse>;
}

export interface TransactionExecutionClient extends Client {
  /**
   * Gets the tracking status of a transaction
   * Error codes:
   *   - INVALID_ARGUMENT if request parameters are invalid
   *   - NOT_FOUND if the transaction cannot be found
   *   - INTERNAL for server-side issues
   */
  getProviderTrackingStatus(
    request: GetProviderTrackingStatusRequest,
    callback: (error: ServiceError | null, response: GetProviderTrackingStatusResponse) => void,
  ): ClientUnaryCall;
  getProviderTrackingStatus(
    request: GetProviderTrackingStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProviderTrackingStatusResponse) => void,
  ): ClientUnaryCall;
  getProviderTrackingStatus(
    request: GetProviderTrackingStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProviderTrackingStatusResponse) => void,
  ): ClientUnaryCall;
}

export const TransactionExecutionClient = makeGenericClientConstructor(
  TransactionExecutionService,
  "ember_agents_onchain.v1.TransactionExecution",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): TransactionExecutionClient;
  service: typeof TransactionExecutionService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
