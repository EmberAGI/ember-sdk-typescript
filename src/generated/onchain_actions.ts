// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: onchain_actions.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal.js";
import { Timestamp } from "./google/protobuf/timestamp.js";

/** Chain type enum */
export enum ChainType {
  UNSPECIFIED = 0,
  EVM = 1,
  SOLANA = 2,
  COSMOS = 3,
  UNRECOGNIZED = -1,
}

export function chainTypeFromJSON(object: any): ChainType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return ChainType.UNSPECIFIED;
    case 1:
    case "EVM":
      return ChainType.EVM;
    case 2:
    case "SOLANA":
      return ChainType.SOLANA;
    case 3:
    case "COSMOS":
      return ChainType.COSMOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChainType.UNRECOGNIZED;
  }
}

export function chainTypeToJSON(object: ChainType): string {
  switch (object) {
    case ChainType.UNSPECIFIED:
      return "UNSPECIFIED";
    case ChainType.EVM:
      return "EVM";
    case ChainType.SOLANA:
      return "SOLANA";
    case ChainType.COSMOS:
      return "COSMOS";
    case ChainType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Order type for token swaps */
export enum OrderType {
  ORDER_TYPE_UNSPECIFIED = 0,
  MARKET_BUY = 1,
  MARKET_SELL = 2,
  LIMIT_BUY = 3,
  LIMIT_SELL = 4,
  UNRECOGNIZED = -1,
}

export function orderTypeFromJSON(object: any): OrderType {
  switch (object) {
    case 0:
    case "ORDER_TYPE_UNSPECIFIED":
      return OrderType.ORDER_TYPE_UNSPECIFIED;
    case 1:
    case "MARKET_BUY":
      return OrderType.MARKET_BUY;
    case 2:
    case "MARKET_SELL":
      return OrderType.MARKET_SELL;
    case 3:
    case "LIMIT_BUY":
      return OrderType.LIMIT_BUY;
    case 4:
    case "LIMIT_SELL":
      return OrderType.LIMIT_SELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderType.UNRECOGNIZED;
  }
}

export function orderTypeToJSON(object: OrderType): string {
  switch (object) {
    case OrderType.ORDER_TYPE_UNSPECIFIED:
      return "ORDER_TYPE_UNSPECIFIED";
    case OrderType.MARKET_BUY:
      return "MARKET_BUY";
    case OrderType.MARKET_SELL:
      return "MARKET_SELL";
    case OrderType.LIMIT_BUY:
      return "LIMIT_BUY";
    case OrderType.LIMIT_SELL:
      return "LIMIT_SELL";
    case OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Status of the transaction plan creation */
export enum TransactionPlanStatus {
  TRANSACTION_PLAN_STATUS_UNSPECIFIED = 0,
  /** SUCCESS - Valid transaction data was created */
  SUCCESS = 1,
  /** ERROR - Failed to create valid transaction data */
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function transactionPlanStatusFromJSON(object: any): TransactionPlanStatus {
  switch (object) {
    case 0:
    case "TRANSACTION_PLAN_STATUS_UNSPECIFIED":
      return TransactionPlanStatus.TRANSACTION_PLAN_STATUS_UNSPECIFIED;
    case 1:
    case "SUCCESS":
      return TransactionPlanStatus.SUCCESS;
    case 2:
    case "ERROR":
      return TransactionPlanStatus.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionPlanStatus.UNRECOGNIZED;
  }
}

export function transactionPlanStatusToJSON(object: TransactionPlanStatus): string {
  switch (object) {
    case TransactionPlanStatus.TRANSACTION_PLAN_STATUS_UNSPECIFIED:
      return "TRANSACTION_PLAN_STATUS_UNSPECIFIED";
    case TransactionPlanStatus.SUCCESS:
      return "SUCCESS";
    case TransactionPlanStatus.ERROR:
      return "ERROR";
    case TransactionPlanStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Transaction type for different chains */
export enum TransactionType {
  TRANSACTION_TYPE_UNSPECIFIED = 0,
  EVM_TX = 1,
  SOLANA_TX = 2,
  COSMOS_TX = 3,
  UNRECOGNIZED = -1,
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case "TRANSACTION_TYPE_UNSPECIFIED":
      return TransactionType.TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "EVM_TX":
      return TransactionType.EVM_TX;
    case 2:
    case "SOLANA_TX":
      return TransactionType.SOLANA_TX;
    case 3:
    case "COSMOS_TX":
      return TransactionType.COSMOS_TX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.TRANSACTION_TYPE_UNSPECIFIED:
      return "TRANSACTION_TYPE_UNSPECIFIED";
    case TransactionType.EVM_TX:
      return "EVM_TX";
    case TransactionType.SOLANA_TX:
      return "SOLANA_TX";
    case TransactionType.COSMOS_TX:
      return "COSMOS_TX";
    case TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Chain {
  chainId: string;
  type: ChainType;
  iconUri: string;
  nativeToken?: Token | undefined;
  httpRpcUrl: string;
  name: string;
  blockExplorerUrls: string[];
  /** Timestamps */
  updatedAt?: Date | undefined;
}

export interface Token {
  /** For native tokens, this may be empty. */
  tokenId: string;
  name: string;
  symbol: string;
  isNative: boolean;
  decimals: number;
  chainId: string;
  iconUri: string;
  /**
   * Store as a string to avoid floating-point precision issues.
   * e.g., "123.456789"
   */
  usdPrice: string;
  isVetted: boolean;
  /** Timestamps */
  updatedAt?: Date | undefined;
}

/** Request to get chains, with optional filtering/pagination. */
export interface GetChainsRequest {
  filter: string;
  pageSize: number;
  pageToken: string;
}

export interface GetChainsResponse {
  chains: Chain[];
  nextPageToken: string;
}

/** Request to get tokens, with optional filter by chain_id, plus pagination. */
export interface GetTokensRequest {
  /** If empty, returns tokens across all chains. */
  chainId: string;
  filter: string;
  pageSize: number;
  pageToken: string;
}

export interface GetTokensResponse {
  tokens: Token[];
  nextPageToken: string;
}

/** Identifies a token on a specific chain */
export interface TokenIdentifier {
  chainId: string;
  address: string;
}

/** Request to swap tokens */
export interface SwapTokensRequest {
  orderType: OrderType;
  baseToken?: TokenIdentifier | undefined;
  quoteToken?: TokenIdentifier | undefined;
  amount: string;
  limitPrice?: string | undefined;
  slippageTolerance?:
    | string
    | undefined;
  /** Changed from deadline */
  expiration?: string | undefined;
  recipient: string;
}

/** Error details when transaction plan creation fails */
export interface TransactionPlanError {
  /** e.g., "INSUFFICIENT_LIQUIDITY" */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Additional context about the error */
  details: { [key: string]: string };
}

export interface TransactionPlanError_DetailsEntry {
  key: string;
  value: string;
}

/** Response containing the swap details */
export interface SwapTokensResponse {
  /** Changed from SwapStatus */
  status: TransactionPlanStatus;
  orderType: OrderType;
  /** Echo back the token details */
  baseToken?: TokenIdentifier | undefined;
  quoteToken?:
    | TokenIdentifier
    | undefined;
  /** Fee and transaction details */
  feeBreakdown?: FeeBreakdown | undefined;
  transactionPlan?: TransactionPlan | undefined;
  estimation?:
    | SwapEstimation
    | undefined;
  /** Tracking information from the provider */
  providerTracking?:
    | ProviderTrackingInfo
    | undefined;
  /** Error details if status is ERROR */
  error?: TransactionPlanError | undefined;
}

/** Fee breakdown for the swap */
export interface FeeBreakdown {
  gasFee: string;
  serviceFee: string;
  slippageCost: string;
  total: string;
  feeDenomination: string;
}

/** Chain-specific transaction plan */
export interface TransactionPlan {
  type: TransactionType;
  to: string;
  data: string;
  value: string;
}

/** Estimation details for the swap */
export interface SwapEstimation {
  baseTokenDelta: string;
  quoteTokenDelta: string;
  effectivePrice: string;
  timeEstimate: string;
  expiration: string;
}

/** Tracking information from the provider */
export interface ProviderTrackingInfo {
  requestId: string;
  providerName: string;
  explorerUrl: string;
}

function createBaseChain(): Chain {
  return {
    chainId: "",
    type: 0,
    iconUri: "",
    nativeToken: undefined,
    httpRpcUrl: "",
    name: "",
    blockExplorerUrls: [],
    updatedAt: undefined,
  };
}

export const Chain = {
  encode(message: Chain, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.iconUri !== "") {
      writer.uint32(26).string(message.iconUri);
    }
    if (message.nativeToken !== undefined) {
      Token.encode(message.nativeToken, writer.uint32(34).fork()).ldelim();
    }
    if (message.httpRpcUrl !== "") {
      writer.uint32(42).string(message.httpRpcUrl);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    for (const v of message.blockExplorerUrls) {
      writer.uint32(58).string(v!);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Chain {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.iconUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nativeToken = Token.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.httpRpcUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.blockExplorerUrls.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chain {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      type: isSet(object.type) ? chainTypeFromJSON(object.type) : 0,
      iconUri: isSet(object.iconUri) ? globalThis.String(object.iconUri) : "",
      nativeToken: isSet(object.nativeToken) ? Token.fromJSON(object.nativeToken) : undefined,
      httpRpcUrl: isSet(object.httpRpcUrl) ? globalThis.String(object.httpRpcUrl) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      blockExplorerUrls: globalThis.Array.isArray(object?.blockExplorerUrls)
        ? object.blockExplorerUrls.map((e: any) => globalThis.String(e))
        : [],
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Chain): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.type !== 0) {
      obj.type = chainTypeToJSON(message.type);
    }
    if (message.iconUri !== "") {
      obj.iconUri = message.iconUri;
    }
    if (message.nativeToken !== undefined) {
      obj.nativeToken = Token.toJSON(message.nativeToken);
    }
    if (message.httpRpcUrl !== "") {
      obj.httpRpcUrl = message.httpRpcUrl;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.blockExplorerUrls?.length) {
      obj.blockExplorerUrls = message.blockExplorerUrls;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chain>, I>>(base?: I): Chain {
    return Chain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chain>, I>>(object: I): Chain {
    const message = createBaseChain();
    message.chainId = object.chainId ?? "";
    message.type = object.type ?? 0;
    message.iconUri = object.iconUri ?? "";
    message.nativeToken = (object.nativeToken !== undefined && object.nativeToken !== null)
      ? Token.fromPartial(object.nativeToken)
      : undefined;
    message.httpRpcUrl = object.httpRpcUrl ?? "";
    message.name = object.name ?? "";
    message.blockExplorerUrls = object.blockExplorerUrls?.map((e) => e) || [];
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseToken(): Token {
  return {
    tokenId: "",
    name: "",
    symbol: "",
    isNative: false,
    decimals: 0,
    chainId: "",
    iconUri: "",
    usdPrice: "",
    isVetted: false,
    updatedAt: undefined,
  };
}

export const Token = {
  encode(message: Token, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenId !== "") {
      writer.uint32(10).string(message.tokenId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.isNative !== false) {
      writer.uint32(32).bool(message.isNative);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).int32(message.decimals);
    }
    if (message.chainId !== "") {
      writer.uint32(50).string(message.chainId);
    }
    if (message.iconUri !== "") {
      writer.uint32(58).string(message.iconUri);
    }
    if (message.usdPrice !== "") {
      writer.uint32(66).string(message.usdPrice);
    }
    if (message.isVetted !== false) {
      writer.uint32(72).bool(message.isVetted);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Token {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isNative = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.decimals = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.iconUri = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.usdPrice = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isVetted = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Token {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : false,
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      iconUri: isSet(object.iconUri) ? globalThis.String(object.iconUri) : "",
      usdPrice: isSet(object.usdPrice) ? globalThis.String(object.usdPrice) : "",
      isVetted: isSet(object.isVetted) ? globalThis.Boolean(object.isVetted) : false,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Token): unknown {
    const obj: any = {};
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.isNative !== false) {
      obj.isNative = message.isNative;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.iconUri !== "") {
      obj.iconUri = message.iconUri;
    }
    if (message.usdPrice !== "") {
      obj.usdPrice = message.usdPrice;
    }
    if (message.isVetted !== false) {
      obj.isVetted = message.isVetted;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Token>, I>>(base?: I): Token {
    return Token.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Token>, I>>(object: I): Token {
    const message = createBaseToken();
    message.tokenId = object.tokenId ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.isNative = object.isNative ?? false;
    message.decimals = object.decimals ?? 0;
    message.chainId = object.chainId ?? "";
    message.iconUri = object.iconUri ?? "";
    message.usdPrice = object.usdPrice ?? "";
    message.isVetted = object.isVetted ?? false;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetChainsRequest(): GetChainsRequest {
  return { filter: "", pageSize: 0, pageToken: "" };
}

export const GetChainsRequest = {
  encode(message: GetChainsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChainsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainsRequest {
    return {
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: GetChainsRequest): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainsRequest>, I>>(base?: I): GetChainsRequest {
    return GetChainsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainsRequest>, I>>(object: I): GetChainsRequest {
    const message = createBaseGetChainsRequest();
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetChainsResponse(): GetChainsResponse {
  return { chains: [], nextPageToken: "" };
}

export const GetChainsResponse = {
  encode(message: GetChainsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.chains) {
      Chain.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChainsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chains.push(Chain.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainsResponse {
    return {
      chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => Chain.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: GetChainsResponse): unknown {
    const obj: any = {};
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => Chain.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainsResponse>, I>>(base?: I): GetChainsResponse {
    return GetChainsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainsResponse>, I>>(object: I): GetChainsResponse {
    const message = createBaseGetChainsResponse();
    message.chains = object.chains?.map((e) => Chain.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTokensRequest(): GetTokensRequest {
  return { chainId: "", filter: "", pageSize: 0, pageToken: "" };
}

export const GetTokensRequest = {
  encode(message: GetTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: GetTokensRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensRequest>, I>>(base?: I): GetTokensRequest {
    return GetTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensRequest>, I>>(object: I): GetTokensRequest {
    const message = createBaseGetTokensRequest();
    message.chainId = object.chainId ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetTokensResponse(): GetTokensResponse {
  return { tokens: [], nextPageToken: "" };
}

export const GetTokensResponse = {
  encode(message: GetTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tokens) {
      Token.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokens.push(Token.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensResponse {
    return {
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e: any) => Token.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: GetTokensResponse): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => Token.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensResponse>, I>>(base?: I): GetTokensResponse {
    return GetTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensResponse>, I>>(object: I): GetTokensResponse {
    const message = createBaseGetTokensResponse();
    message.tokens = object.tokens?.map((e) => Token.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseTokenIdentifier(): TokenIdentifier {
  return { chainId: "", address: "" };
}

export const TokenIdentifier = {
  encode(message: TokenIdentifier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenIdentifier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenIdentifier {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: TokenIdentifier): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenIdentifier>, I>>(base?: I): TokenIdentifier {
    return TokenIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenIdentifier>, I>>(object: I): TokenIdentifier {
    const message = createBaseTokenIdentifier();
    message.chainId = object.chainId ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseSwapTokensRequest(): SwapTokensRequest {
  return {
    orderType: 0,
    baseToken: undefined,
    quoteToken: undefined,
    amount: "",
    limitPrice: undefined,
    slippageTolerance: undefined,
    expiration: undefined,
    recipient: "",
  };
}

export const SwapTokensRequest = {
  encode(message: SwapTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderType !== 0) {
      writer.uint32(8).int32(message.orderType);
    }
    if (message.baseToken !== undefined) {
      TokenIdentifier.encode(message.baseToken, writer.uint32(18).fork()).ldelim();
    }
    if (message.quoteToken !== undefined) {
      TokenIdentifier.encode(message.quoteToken, writer.uint32(26).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.limitPrice !== undefined) {
      writer.uint32(42).string(message.limitPrice);
    }
    if (message.slippageTolerance !== undefined) {
      writer.uint32(50).string(message.slippageTolerance);
    }
    if (message.expiration !== undefined) {
      writer.uint32(58).string(message.expiration);
    }
    if (message.recipient !== "") {
      writer.uint32(66).string(message.recipient);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baseToken = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.quoteToken = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.limitPrice = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.slippageTolerance = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.expiration = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.recipient = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapTokensRequest {
    return {
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      baseToken: isSet(object.baseToken) ? TokenIdentifier.fromJSON(object.baseToken) : undefined,
      quoteToken: isSet(object.quoteToken) ? TokenIdentifier.fromJSON(object.quoteToken) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      limitPrice: isSet(object.limitPrice) ? globalThis.String(object.limitPrice) : undefined,
      slippageTolerance: isSet(object.slippageTolerance) ? globalThis.String(object.slippageTolerance) : undefined,
      expiration: isSet(object.expiration) ? globalThis.String(object.expiration) : undefined,
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : "",
    };
  },

  toJSON(message: SwapTokensRequest): unknown {
    const obj: any = {};
    if (message.orderType !== 0) {
      obj.orderType = orderTypeToJSON(message.orderType);
    }
    if (message.baseToken !== undefined) {
      obj.baseToken = TokenIdentifier.toJSON(message.baseToken);
    }
    if (message.quoteToken !== undefined) {
      obj.quoteToken = TokenIdentifier.toJSON(message.quoteToken);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.limitPrice !== undefined) {
      obj.limitPrice = message.limitPrice;
    }
    if (message.slippageTolerance !== undefined) {
      obj.slippageTolerance = message.slippageTolerance;
    }
    if (message.expiration !== undefined) {
      obj.expiration = message.expiration;
    }
    if (message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapTokensRequest>, I>>(base?: I): SwapTokensRequest {
    return SwapTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapTokensRequest>, I>>(object: I): SwapTokensRequest {
    const message = createBaseSwapTokensRequest();
    message.orderType = object.orderType ?? 0;
    message.baseToken = (object.baseToken !== undefined && object.baseToken !== null)
      ? TokenIdentifier.fromPartial(object.baseToken)
      : undefined;
    message.quoteToken = (object.quoteToken !== undefined && object.quoteToken !== null)
      ? TokenIdentifier.fromPartial(object.quoteToken)
      : undefined;
    message.amount = object.amount ?? "";
    message.limitPrice = object.limitPrice ?? undefined;
    message.slippageTolerance = object.slippageTolerance ?? undefined;
    message.expiration = object.expiration ?? undefined;
    message.recipient = object.recipient ?? "";
    return message;
  },
};

function createBaseTransactionPlanError(): TransactionPlanError {
  return { code: "", message: "", details: {} };
}

export const TransactionPlanError = {
  encode(message: TransactionPlanError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      TransactionPlanError_DetailsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionPlanError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionPlanError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TransactionPlanError_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.details[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionPlanError {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TransactionPlanError): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionPlanError>, I>>(base?: I): TransactionPlanError {
    return TransactionPlanError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionPlanError>, I>>(object: I): TransactionPlanError {
    const message = createBaseTransactionPlanError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTransactionPlanError_DetailsEntry(): TransactionPlanError_DetailsEntry {
  return { key: "", value: "" };
}

export const TransactionPlanError_DetailsEntry = {
  encode(message: TransactionPlanError_DetailsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionPlanError_DetailsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionPlanError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionPlanError_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionPlanError_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionPlanError_DetailsEntry>, I>>(
    base?: I,
  ): TransactionPlanError_DetailsEntry {
    return TransactionPlanError_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionPlanError_DetailsEntry>, I>>(
    object: I,
  ): TransactionPlanError_DetailsEntry {
    const message = createBaseTransactionPlanError_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSwapTokensResponse(): SwapTokensResponse {
  return {
    status: 0,
    orderType: 0,
    baseToken: undefined,
    quoteToken: undefined,
    feeBreakdown: undefined,
    transactionPlan: undefined,
    estimation: undefined,
    providerTracking: undefined,
    error: undefined,
  };
}

export const SwapTokensResponse = {
  encode(message: SwapTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    if (message.baseToken !== undefined) {
      TokenIdentifier.encode(message.baseToken, writer.uint32(26).fork()).ldelim();
    }
    if (message.quoteToken !== undefined) {
      TokenIdentifier.encode(message.quoteToken, writer.uint32(34).fork()).ldelim();
    }
    if (message.feeBreakdown !== undefined) {
      FeeBreakdown.encode(message.feeBreakdown, writer.uint32(42).fork()).ldelim();
    }
    if (message.transactionPlan !== undefined) {
      TransactionPlan.encode(message.transactionPlan, writer.uint32(50).fork()).ldelim();
    }
    if (message.estimation !== undefined) {
      SwapEstimation.encode(message.estimation, writer.uint32(58).fork()).ldelim();
    }
    if (message.providerTracking !== undefined) {
      ProviderTrackingInfo.encode(message.providerTracking, writer.uint32(66).fork()).ldelim();
    }
    if (message.error !== undefined) {
      TransactionPlanError.encode(message.error, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseToken = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.quoteToken = TokenIdentifier.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeBreakdown = FeeBreakdown.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionPlan = TransactionPlan.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.estimation = SwapEstimation.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.providerTracking = ProviderTrackingInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.error = TransactionPlanError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapTokensResponse {
    return {
      status: isSet(object.status) ? transactionPlanStatusFromJSON(object.status) : 0,
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      baseToken: isSet(object.baseToken) ? TokenIdentifier.fromJSON(object.baseToken) : undefined,
      quoteToken: isSet(object.quoteToken) ? TokenIdentifier.fromJSON(object.quoteToken) : undefined,
      feeBreakdown: isSet(object.feeBreakdown) ? FeeBreakdown.fromJSON(object.feeBreakdown) : undefined,
      transactionPlan: isSet(object.transactionPlan) ? TransactionPlan.fromJSON(object.transactionPlan) : undefined,
      estimation: isSet(object.estimation) ? SwapEstimation.fromJSON(object.estimation) : undefined,
      providerTracking: isSet(object.providerTracking)
        ? ProviderTrackingInfo.fromJSON(object.providerTracking)
        : undefined,
      error: isSet(object.error) ? TransactionPlanError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: SwapTokensResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = transactionPlanStatusToJSON(message.status);
    }
    if (message.orderType !== 0) {
      obj.orderType = orderTypeToJSON(message.orderType);
    }
    if (message.baseToken !== undefined) {
      obj.baseToken = TokenIdentifier.toJSON(message.baseToken);
    }
    if (message.quoteToken !== undefined) {
      obj.quoteToken = TokenIdentifier.toJSON(message.quoteToken);
    }
    if (message.feeBreakdown !== undefined) {
      obj.feeBreakdown = FeeBreakdown.toJSON(message.feeBreakdown);
    }
    if (message.transactionPlan !== undefined) {
      obj.transactionPlan = TransactionPlan.toJSON(message.transactionPlan);
    }
    if (message.estimation !== undefined) {
      obj.estimation = SwapEstimation.toJSON(message.estimation);
    }
    if (message.providerTracking !== undefined) {
      obj.providerTracking = ProviderTrackingInfo.toJSON(message.providerTracking);
    }
    if (message.error !== undefined) {
      obj.error = TransactionPlanError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapTokensResponse>, I>>(base?: I): SwapTokensResponse {
    return SwapTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapTokensResponse>, I>>(object: I): SwapTokensResponse {
    const message = createBaseSwapTokensResponse();
    message.status = object.status ?? 0;
    message.orderType = object.orderType ?? 0;
    message.baseToken = (object.baseToken !== undefined && object.baseToken !== null)
      ? TokenIdentifier.fromPartial(object.baseToken)
      : undefined;
    message.quoteToken = (object.quoteToken !== undefined && object.quoteToken !== null)
      ? TokenIdentifier.fromPartial(object.quoteToken)
      : undefined;
    message.feeBreakdown = (object.feeBreakdown !== undefined && object.feeBreakdown !== null)
      ? FeeBreakdown.fromPartial(object.feeBreakdown)
      : undefined;
    message.transactionPlan = (object.transactionPlan !== undefined && object.transactionPlan !== null)
      ? TransactionPlan.fromPartial(object.transactionPlan)
      : undefined;
    message.estimation = (object.estimation !== undefined && object.estimation !== null)
      ? SwapEstimation.fromPartial(object.estimation)
      : undefined;
    message.providerTracking = (object.providerTracking !== undefined && object.providerTracking !== null)
      ? ProviderTrackingInfo.fromPartial(object.providerTracking)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? TransactionPlanError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseFeeBreakdown(): FeeBreakdown {
  return { gasFee: "", serviceFee: "", slippageCost: "", total: "", feeDenomination: "" };
}

export const FeeBreakdown = {
  encode(message: FeeBreakdown, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.gasFee !== "") {
      writer.uint32(10).string(message.gasFee);
    }
    if (message.serviceFee !== "") {
      writer.uint32(18).string(message.serviceFee);
    }
    if (message.slippageCost !== "") {
      writer.uint32(26).string(message.slippageCost);
    }
    if (message.total !== "") {
      writer.uint32(34).string(message.total);
    }
    if (message.feeDenomination !== "") {
      writer.uint32(42).string(message.feeDenomination);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeeBreakdown {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeBreakdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gasFee = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceFee = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.slippageCost = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.total = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeDenomination = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeeBreakdown {
    return {
      gasFee: isSet(object.gasFee) ? globalThis.String(object.gasFee) : "",
      serviceFee: isSet(object.serviceFee) ? globalThis.String(object.serviceFee) : "",
      slippageCost: isSet(object.slippageCost) ? globalThis.String(object.slippageCost) : "",
      total: isSet(object.total) ? globalThis.String(object.total) : "",
      feeDenomination: isSet(object.feeDenomination) ? globalThis.String(object.feeDenomination) : "",
    };
  },

  toJSON(message: FeeBreakdown): unknown {
    const obj: any = {};
    if (message.gasFee !== "") {
      obj.gasFee = message.gasFee;
    }
    if (message.serviceFee !== "") {
      obj.serviceFee = message.serviceFee;
    }
    if (message.slippageCost !== "") {
      obj.slippageCost = message.slippageCost;
    }
    if (message.total !== "") {
      obj.total = message.total;
    }
    if (message.feeDenomination !== "") {
      obj.feeDenomination = message.feeDenomination;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeBreakdown>, I>>(base?: I): FeeBreakdown {
    return FeeBreakdown.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeBreakdown>, I>>(object: I): FeeBreakdown {
    const message = createBaseFeeBreakdown();
    message.gasFee = object.gasFee ?? "";
    message.serviceFee = object.serviceFee ?? "";
    message.slippageCost = object.slippageCost ?? "";
    message.total = object.total ?? "";
    message.feeDenomination = object.feeDenomination ?? "";
    return message;
  },
};

function createBaseTransactionPlan(): TransactionPlan {
  return { type: 0, to: "", data: "", value: "" };
}

export const TransactionPlan = {
  encode(message: TransactionPlan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionPlan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionPlan {
    return {
      type: isSet(object.type) ? transactionTypeFromJSON(object.type) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionPlan): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = transactionTypeToJSON(message.type);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionPlan>, I>>(base?: I): TransactionPlan {
    return TransactionPlan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionPlan>, I>>(object: I): TransactionPlan {
    const message = createBaseTransactionPlan();
    message.type = object.type ?? 0;
    message.to = object.to ?? "";
    message.data = object.data ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSwapEstimation(): SwapEstimation {
  return { baseTokenDelta: "", quoteTokenDelta: "", effectivePrice: "", timeEstimate: "", expiration: "" };
}

export const SwapEstimation = {
  encode(message: SwapEstimation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseTokenDelta !== "") {
      writer.uint32(10).string(message.baseTokenDelta);
    }
    if (message.quoteTokenDelta !== "") {
      writer.uint32(18).string(message.quoteTokenDelta);
    }
    if (message.effectivePrice !== "") {
      writer.uint32(26).string(message.effectivePrice);
    }
    if (message.timeEstimate !== "") {
      writer.uint32(34).string(message.timeEstimate);
    }
    if (message.expiration !== "") {
      writer.uint32(42).string(message.expiration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapEstimation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapEstimation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseTokenDelta = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quoteTokenDelta = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.effectivePrice = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeEstimate = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expiration = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapEstimation {
    return {
      baseTokenDelta: isSet(object.baseTokenDelta) ? globalThis.String(object.baseTokenDelta) : "",
      quoteTokenDelta: isSet(object.quoteTokenDelta) ? globalThis.String(object.quoteTokenDelta) : "",
      effectivePrice: isSet(object.effectivePrice) ? globalThis.String(object.effectivePrice) : "",
      timeEstimate: isSet(object.timeEstimate) ? globalThis.String(object.timeEstimate) : "",
      expiration: isSet(object.expiration) ? globalThis.String(object.expiration) : "",
    };
  },

  toJSON(message: SwapEstimation): unknown {
    const obj: any = {};
    if (message.baseTokenDelta !== "") {
      obj.baseTokenDelta = message.baseTokenDelta;
    }
    if (message.quoteTokenDelta !== "") {
      obj.quoteTokenDelta = message.quoteTokenDelta;
    }
    if (message.effectivePrice !== "") {
      obj.effectivePrice = message.effectivePrice;
    }
    if (message.timeEstimate !== "") {
      obj.timeEstimate = message.timeEstimate;
    }
    if (message.expiration !== "") {
      obj.expiration = message.expiration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapEstimation>, I>>(base?: I): SwapEstimation {
    return SwapEstimation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapEstimation>, I>>(object: I): SwapEstimation {
    const message = createBaseSwapEstimation();
    message.baseTokenDelta = object.baseTokenDelta ?? "";
    message.quoteTokenDelta = object.quoteTokenDelta ?? "";
    message.effectivePrice = object.effectivePrice ?? "";
    message.timeEstimate = object.timeEstimate ?? "";
    message.expiration = object.expiration ?? "";
    return message;
  },
};

function createBaseProviderTrackingInfo(): ProviderTrackingInfo {
  return { requestId: "", providerName: "", explorerUrl: "" };
}

export const ProviderTrackingInfo = {
  encode(message: ProviderTrackingInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.providerName !== "") {
      writer.uint32(18).string(message.providerName);
    }
    if (message.explorerUrl !== "") {
      writer.uint32(26).string(message.explorerUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderTrackingInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderTrackingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.providerName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.explorerUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderTrackingInfo {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      providerName: isSet(object.providerName) ? globalThis.String(object.providerName) : "",
      explorerUrl: isSet(object.explorerUrl) ? globalThis.String(object.explorerUrl) : "",
    };
  },

  toJSON(message: ProviderTrackingInfo): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.providerName !== "") {
      obj.providerName = message.providerName;
    }
    if (message.explorerUrl !== "") {
      obj.explorerUrl = message.explorerUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderTrackingInfo>, I>>(base?: I): ProviderTrackingInfo {
    return ProviderTrackingInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderTrackingInfo>, I>>(object: I): ProviderTrackingInfo {
    const message = createBaseProviderTrackingInfo();
    message.requestId = object.requestId ?? "";
    message.providerName = object.providerName ?? "";
    message.explorerUrl = object.explorerUrl ?? "";
    return message;
  },
};

/**
 * The DataService provides information about chains and tokens.
 *
 * Possible gRPC error codes for these methods:
 * - INVALID_ARGUMENT: The request parameters are malformed or invalid.
 * - NOT_FOUND: The requested resource(s) could not be found.
 * - INTERNAL: An unexpected server-side error occurred.
 * - UNAUTHENTICATED / PERMISSION_DENIED: If authentication or authorization fails.
 */
export type DataServiceService = typeof DataServiceService;
export const DataServiceService = {
  /**
   * Returns a list of supported chains.
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getChains: {
    path: "/ember_agents_onchain.v1.DataService/GetChains",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetChainsRequest) => Buffer.from(GetChainsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetChainsRequest.decode(value),
    responseSerialize: (value: GetChainsResponse) => Buffer.from(GetChainsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetChainsResponse.decode(value),
  },
  /**
   * Returns a list of tokens (potentially filtered by chain or other criteria).
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - NOT_FOUND if no tokens match the request.
   *   - INTERNAL for server-side issues.
   */
  getTokens: {
    path: "/ember_agents_onchain.v1.DataService/GetTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTokensRequest) => Buffer.from(GetTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTokensRequest.decode(value),
    responseSerialize: (value: GetTokensResponse) => Buffer.from(GetTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTokensResponse.decode(value),
  },
} as const;

export interface DataServiceServer extends UntypedServiceImplementation {
  /**
   * Returns a list of supported chains.
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getChains: handleUnaryCall<GetChainsRequest, GetChainsResponse>;
  /**
   * Returns a list of tokens (potentially filtered by chain or other criteria).
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - NOT_FOUND if no tokens match the request.
   *   - INTERNAL for server-side issues.
   */
  getTokens: handleUnaryCall<GetTokensRequest, GetTokensResponse>;
}

export interface DataServiceClient extends Client {
  /**
   * Returns a list of supported chains.
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - INTERNAL for server-side issues.
   */
  getChains(
    request: GetChainsRequest,
    callback: (error: ServiceError | null, response: GetChainsResponse) => void,
  ): ClientUnaryCall;
  getChains(
    request: GetChainsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetChainsResponse) => void,
  ): ClientUnaryCall;
  getChains(
    request: GetChainsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetChainsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns a list of tokens (potentially filtered by chain or other criteria).
   * Error codes:
   *   - INVALID_ARGUMENT if filtering or pagination parameters are invalid.
   *   - NOT_FOUND if no tokens match the request.
   *   - INTERNAL for server-side issues.
   */
  getTokens(
    request: GetTokensRequest,
    callback: (error: ServiceError | null, response: GetTokensResponse) => void,
  ): ClientUnaryCall;
  getTokens(
    request: GetTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTokensResponse) => void,
  ): ClientUnaryCall;
  getTokens(
    request: GetTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTokensResponse) => void,
  ): ClientUnaryCall;
}

export const DataServiceClient = makeGenericClientConstructor(
  DataServiceService,
  "ember_agents_onchain.v1.DataService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DataServiceClient;
  service: typeof DataServiceService;
  serviceName: string;
};

/** New service for transaction creation */
export type CreateTransactionService = typeof CreateTransactionService;
export const CreateTransactionService = {
  /**
   * Creates a transaction for swapping tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if tokens or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the swap is not possible
   */
  swapTokens: {
    path: "/ember_agents_onchain.v1.CreateTransaction/SwapTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SwapTokensRequest) => Buffer.from(SwapTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SwapTokensRequest.decode(value),
    responseSerialize: (value: SwapTokensResponse) => Buffer.from(SwapTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SwapTokensResponse.decode(value),
  },
} as const;

export interface CreateTransactionServer extends UntypedServiceImplementation {
  /**
   * Creates a transaction for swapping tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if tokens or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the swap is not possible
   */
  swapTokens: handleUnaryCall<SwapTokensRequest, SwapTokensResponse>;
}

export interface CreateTransactionClient extends Client {
  /**
   * Creates a transaction for swapping tokens.
   * Error codes:
   *   - INVALID_ARGUMENT if the request parameters are invalid
   *   - NOT_FOUND if tokens or chain cannot be found
   *   - INTERNAL for server-side issues
   *   - FAILED_PRECONDITION if the swap is not possible
   */
  swapTokens(
    request: SwapTokensRequest,
    callback: (error: ServiceError | null, response: SwapTokensResponse) => void,
  ): ClientUnaryCall;
  swapTokens(
    request: SwapTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SwapTokensResponse) => void,
  ): ClientUnaryCall;
  swapTokens(
    request: SwapTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SwapTokensResponse) => void,
  ): ClientUnaryCall;
}

export const CreateTransactionClient = makeGenericClientConstructor(
  CreateTransactionService,
  "ember_agents_onchain.v1.CreateTransaction",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CreateTransactionClient;
  service: typeof CreateTransactionService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
